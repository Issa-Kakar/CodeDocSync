{
  "version": "1.0",
  "examples": [
    {
      "function_name": "analyze_matched_pair",
      "module_path": "codedocsync\\analyzer\\integration.py",
      "function_signature": "FunctionSignature(name='analyze_matched_pair', parameters=[FunctionParameter(name='pair', type_annotation='MatchedPair', default_value=None, is_required=True), FunctionParameter(name='config', type_annotation='AnalysisConfig | None', default_value='None', is_required=False), FunctionParameter(name='cache', type_annotation='AnalysisCache | None', default_value='None', is_required=False), FunctionParameter(name='rule_engine', type_annotation='RuleEngine | None', default_value='None', is_required=False), FunctionParameter(name='llm_analyzer', type_annotation='LLMAnalyzer | None', default_value='None', is_required=False)], return_type='AnalysisResult', is_async=True, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Main entry point for analyzing a matched function-documentation pair.\n\nThis function orchestrates the complete analysis process:\n1. Run rule engine checks (fast path)\n2. Determine if LLM analysis needed based on confidence\n3. Run LLM analysis if required\n4. Merge and sort results\n5. Generate final suggestions\n\nArgs:\n    pair: The matched function-documentation pair to analyze\n    config: Optional analysis configuration (uses defaults if None)\n    cache: Optional cache instance for performance\n    rule_engine: Optional rule engine instance (creates default if None)\n    llm_analyzer: Optional LLM analyzer instance (creates default if None)\n\nReturns:\n    AnalysisResult: Complete analysis with all detected issues\n\nRaises:\n    ValueError: If the matched pair is invalid\n    AnalysisError: If analysis fails unrecoverably",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 5,
      "quality_score": 5
    },
    {
      "function_name": "_generate_cache_key",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_generate_cache_key', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='function_signature', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='docstring', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='analysis_types', type_annotation='list', default_value=None, is_required=True), FunctionParameter(name='model', type_annotation='str', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Generate deterministic cache key.\n\nCache key generation is critical for cache effectiveness.\nMust be deterministic and collision-resistant.\n\nArgs:\n    function_signature: String representation of function signature\n    docstring: Raw docstring text\n    analysis_types: List of analysis types being performed\n    model: Model identifier\n\nReturns:\n    MD5 hash as cache key",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 5
    },
    {
      "function_name": "analyze_batch",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='analyze_batch', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='requests', type_annotation='list[LLMAnalysisRequest]', default_value=None, is_required=True), FunctionParameter(name='max_concurrent', type_annotation='int', default_value='10', is_required=False), FunctionParameter(name='progress_callback', type_annotation='Callable | None', default_value='None', is_required=False)], return_type='list[LLMAnalysisResponse]', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Analyze multiple functions efficiently with smart batching.\n\nImplements batching strategies:\n- Group similar functions together (better cache hits)\n- Prioritize by file modification time\n- Limit concurrent requests to avoid rate limits\n- Use asyncio.gather with return_exceptions=True\n\nArgs:\n    requests: List of LLM analysis requests\n    max_concurrent: Maximum concurrent analysis operations\n    progress_callback: Optional callback function for progress updates\n\nReturns:\n    List of LLM analysis responses (same order as requests)",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 5
    },
    {
      "function_name": "warm_cache",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='warm_cache', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='functions', type_annotation=\"list['ParsedFunction']\", default_value=None, is_required=True), FunctionParameter(name='max_concurrent', type_annotation='int', default_value='5', is_required=False), FunctionParameter(name='progress_callback', type_annotation='Callable | None', default_value='None', is_required=False)], return_type='dict[str, Any]', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Pre-populate cache for high-value functions.\n\nIdentifies functions that would benefit from caching:\n- Public API functions (no leading underscore)\n- Frequently changed functions\n- Complex functions (>50 lines or >5 parameters)\n\nArgs:\n    functions: List of functions to potentially cache\n    max_concurrent: Maximum concurrent warming operations\n    progress_callback: Optional progress callback\n\nReturns:\n    Statistics about the warming operation",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 5
    },
    {
      "function_name": "warm_cache",
      "module_path": "codedocsync\\analyzer\\llm_cache.py",
      "function_signature": "FunctionSignature(name='warm_cache', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='functions', type_annotation='list[ParsedFunction]', default_value=None, is_required=True), FunctionParameter(name='max_concurrent', type_annotation='int', default_value='5', is_required=False)], return_type='dict[str, Any]', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Pre-populate cache for high-value functions.\n\nIdentifies functions that would benefit from caching:\n- Public API functions (no leading underscore)\n- Frequently changed functions\n- Complex functions (>50 lines)\n\nArgs:\n    functions: List of functions to potentially cache\n    max_concurrent: Maximum concurrent warming operations\n\nReturns:\n    Statistics about the warming operation",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 5
    },
    {
      "function_name": "validate_semantic_match",
      "module_path": "codedocsync\\matcher\\semantic_scorer.py",
      "function_signature": "FunctionSignature(name='validate_semantic_match', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='source_function', type_annotation='ParsedFunction', default_value=None, is_required=True), FunctionParameter(name='candidate_function_id', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='raw_similarity', type_annotation='float', default_value=None, is_required=True)], return_type='tuple[bool, float]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Validate and adjust semantic match score.\n\nApplies architectural rules for semantic matching validation:\n- Module distance checks\n- Naming pattern recognition\n- Parameter count validation (when available)\n\nArgs:\n    source_function: Function looking for a match\n    candidate_function_id: ID of potential match function\n    raw_similarity: Raw similarity score from embedding comparison\n\nReturns:\n    (is_valid, adjusted_score) tuple",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 5
    },
    {
      "function_name": "parse_python_file",
      "module_path": "codedocsync\\parser\\ast_parser.py",
      "function_signature": "FunctionSignature(name='parse_python_file', parameters=[FunctionParameter(name='file_path', type_annotation='str', default_value=None, is_required=True)], return_type='list[ParsedFunction]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Parse Python file with comprehensive error handling.\n\nPerformance targets:\n- Small file (<100 lines): <10ms\n- Medium file (100-1000 lines): <50ms\n- Large file (>1000 lines): <200ms\n\nArgs:\n    file_path: Path to the Python file to parse\n\nReturns:\n    List of ParsedFunction objects representing all functions found\n\nRaises:\n    ParsingError: If file cannot be parsed or accessed",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 5
    },
    {
      "function_name": "parse_python_file_lazy",
      "module_path": "codedocsync\\parser\\ast_parser.py",
      "function_signature": "FunctionSignature(name='parse_python_file_lazy', parameters=[FunctionParameter(name='file_path', type_annotation='str', default_value=None, is_required=True)], return_type='Generator[ParsedFunction, None, None]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Lazy parsing using generators for memory efficiency.\n\nThis function yields ParsedFunction objects one at a time instead of loading\nall functions into memory at once. Useful for large files or when processing\nmany files.\n\nArgs:\n    file_path: Path to the Python file to parse\n\nYields:\n    ParsedFunction objects one at a time\n\nRaises:\n    ParsingError: If file cannot be parsed or accessed",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 5
    },
    {
      "function_name": "measure",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='measure', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='operation', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='**metadata', type_annotation='Any', default_value=None, is_required=False)], return_type='Iterator[None]', is_async=False, is_method=True, decorators=['contextmanager'])",
      "docstring_format": "google",
      "docstring_content": "Measure operation performance.\n\nArgs:\n    operation: Operation name\n    **metadata: Additional metadata to store\n\nYields:\n    None\n\nExample:\n    with monitor.measure(\"parameter_suggestion\", issue_type=\"missing\"):\n        # Generate suggestion",
      "has_params": true,
      "has_returns": true,
      "has_examples": true,
      "complexity_score": 3,
      "quality_score": 5
    },
    {
      "function_name": "enhance_analysis_result_with_suggestions",
      "module_path": "codedocsync\\suggestions\\__init__.py",
      "function_signature": "FunctionSignature(name='enhance_analysis_result_with_suggestions', parameters=[FunctionParameter(name='analysis_result', type_annotation='Any', default_value=None, is_required=True), FunctionParameter(name='config', type_annotation='SuggestionConfig | None', default_value='None', is_required=False)], return_type='Any', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Enhance an AnalysisResult with suggestions.\n\nThis function integrates with the analyzer module and adds rich suggestions\nto analysis results using the SuggestionIntegration system.\n\nArgs:\n    analysis_result: AnalysisResult from analyzer module\n    config: Optional suggestion configuration\n\nReturns:\n    EnhancedAnalysisResult with suggestions",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 5
    },
    {
      "function_name": "_group_requests_for_efficiency",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_group_requests_for_efficiency', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='requests', type_annotation='list[LLMAnalysisRequest]', default_value=None, is_required=True)], return_type='list[list[tuple[LLMAnalysisRequest, int]]]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Group requests for better cache efficiency and performance.\n\nGrouping strategies:\n1. Group by analysis type (similar prompts = better cache hits)\n2. Prioritize by function complexity (complex functions first)\n3. Group by file path (similar context)\n\nArgs:\n    requests: List of requests to group\n\nReturns:\n    List of groups, each containing (request, original_index) tuples",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 5
    },
    {
      "function_name": "analyze_with_fallback",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='analyze_with_fallback', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True)], return_type='AnalysisResult', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Analyze with multiple fallback strategies.\n\nImplements graceful degradation through multiple fallback strategies:\n1. Try full LLM analysis with circuit breaker protection\n2. Try simpler prompts with reduced complexity\n3. Try rule engine only analysis\n4. Return minimal analysis as last resort\n\nArgs:\n    request: LLM analysis request\n\nReturns:\n    AnalysisResult with appropriate confidence adjustment",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 5
    },
    {
      "function_name": "_analyze_with_simple_prompts",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_analyze_with_simple_prompts', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True)], return_type='AnalysisResult', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform LLM analysis with simplified prompts.\n\nUses shorter, simpler prompts to reduce the chance of failure.\n\nArgs:\n    request: LLM analysis request\n\nReturns:\n    AnalysisResult from simplified LLM analysis",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 5
    },
    {
      "function_name": "_analyze_with_rules_only",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_analyze_with_rules_only', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True)], return_type='AnalysisResult', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform rule-based analysis only.\n\nFalls back to rule engine when LLM analysis is not available.\n\nArgs:\n    request: LLM analysis request\n\nReturns:\n    AnalysisResult from rule engine only",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 5
    },
    {
      "function_name": "_minimal_analysis",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_minimal_analysis', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True)], return_type='AnalysisResult', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Return minimal analysis when all other strategies fail.\n\nCreates a basic analysis result with minimal information.\n\nArgs:\n    request: LLM analysis request\n\nReturns:\n    Minimal AnalysisResult",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 5
    },
    {
      "function_name": "match_functions",
      "module_path": "codedocsync\\matcher\\direct_matcher.py",
      "function_signature": "FunctionSignature(name='match_functions', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='functions', type_annotation='list[ParsedFunction]', default_value=None, is_required=True)], return_type='MatchResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Match functions to their documentation.\n\nArgs:\n    functions: List of parsed functions from a file/project\n\nReturns:\n    MatchResult containing all matches and unmatched functions\n\nExample:\n    >>> matcher = DirectMatcher()\n    >>> result = matcher.match_functions(parsed_functions)\n    >>> print(f\"Matched {result.match_rate:.1%} of functions\")",
      "has_params": true,
      "has_returns": true,
      "has_examples": true,
      "complexity_score": 2,
      "quality_score": 5
    },
    {
      "function_name": "match_file",
      "module_path": "codedocsync\\matcher\\facade.py",
      "function_signature": "FunctionSignature(name='match_file', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='file_path', type_annotation='str | Path', default_value=None, is_required=True)], return_type='MatchResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Parse and match functions in a single file.\n\nArgs:\n    file_path: Path to Python file\n\nReturns:\n    MatchResult with all matches\n\nExample:\n    >>> facade = MatchingFacade()\n    >>> result = facade.match_file(\"mymodule.py\")\n    >>> print(f\"Matched {result.match_rate:.1%} of functions\")",
      "has_params": true,
      "has_returns": true,
      "has_examples": true,
      "complexity_score": 2,
      "quality_score": 5
    },
    {
      "function_name": "parse_file",
      "module_path": "codedocsync\\parser\\integrated_parser.py",
      "function_signature": "FunctionSignature(name='parse_file', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='file_path', type_annotation='str', default_value=None, is_required=True)], return_type='list[ParsedFunction]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Parse file and enrich with parsed docstrings.\n\nSteps:\n1. Parse AST to get functions\n2. Parse each function's docstring\n3. Attach parsed docstring to function\n4. Return enriched functions\n\nArgs:\n    file_path: Path to Python file to parse\n\nReturns:\n    List of ParsedFunction objects with enriched docstrings\n\nRaises:\n    FileNotFoundError: If file does not exist\n    ParsingError: If parsing fails",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 5
    },
    {
      "function_name": "analyze_multiple_pairs",
      "module_path": "codedocsync\\analyzer\\integration.py",
      "function_signature": "FunctionSignature(name='analyze_multiple_pairs', parameters=[FunctionParameter(name='pairs', type_annotation='list[MatchedPair]', default_value=None, is_required=True), FunctionParameter(name='config', type_annotation='AnalysisConfig | None', default_value='None', is_required=False), FunctionParameter(name='cache', type_annotation='AnalysisCache | None', default_value='None', is_required=False), FunctionParameter(name='rule_engine', type_annotation='RuleEngine | None', default_value='None', is_required=False), FunctionParameter(name='llm_analyzer', type_annotation='LLMAnalyzer | None', default_value='None', is_required=False)], return_type='list[AnalysisResult]', is_async=True, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Analyze multiple matched pairs with optional parallelization.\n\nArgs:\n    pairs: List of matched pairs to analyze\n    config: Analysis configuration\n    cache: Optional shared cache\n    rule_engine: Shared rule engine instance\n    llm_analyzer: Shared LLM analyzer instance\n\nReturns:\n    List of analysis results in the same order as input pairs",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 5,
      "quality_score": 4
    },
    {
      "function_name": "format_prompt",
      "module_path": "codedocsync\\analyzer\\prompt_templates.py",
      "function_signature": "FunctionSignature(name='format_prompt', parameters=[FunctionParameter(name='analysis_type', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='signature', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='source_code', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='docstring', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='rule_issues', type_annotation='str | None', default_value='None', is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Format a prompt template with actual function data.\n\nArgs:\n    analysis_type: Type of analysis to perform\n    signature: Function signature string\n    source_code: Function implementation source code\n    docstring: Current documentation\n    rule_issues: Optional summary of rule-based issues found\n    **kwargs: Additional formatting variables\n\nReturns:\n    str: Formatted prompt ready for LLM\n\nRaises:\n    ValueError: If analysis_type is not supported\n    KeyError: If required formatting variables are missing",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 5,
      "quality_score": 4
    },
    {
      "function_name": "generate_parameter_suggestion",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='generate_parameter_suggestion', parameters=[FunctionParameter(name='issue_type', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='param_name', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='expected_value', type_annotation='str', default_value=\"''\", is_required=False), FunctionParameter(name='actual_value', type_annotation='str', default_value=\"''\", is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Create fix suggestion for parameter issues.\n\nArgs:\n    issue_type: Type of issue (from ISSUE_TYPES)\n    param_name: Parameter name\n    expected_value: Expected/correct value\n    actual_value: Current/incorrect value\n    **kwargs: Additional context\n\nReturns:\n    Formatted suggestion string",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 5,
      "quality_score": 4
    },
    {
      "function_name": "create_suggestion_context",
      "module_path": "codedocsync\\suggestions\\__init__.py",
      "function_signature": "FunctionSignature(name='create_suggestion_context', parameters=[FunctionParameter(name='issue', type_annotation='Any', default_value=None, is_required=True), FunctionParameter(name='function', type_annotation='Any', default_value=None, is_required=True), FunctionParameter(name='docstring', type_annotation='Any | None', default_value='None', is_required=False), FunctionParameter(name='project_style', type_annotation='str', default_value=\"'google'\", is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type='SuggestionContext', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Factory function to create a SuggestionContext with sensible defaults.\n\nArgs:\n    issue: InconsistencyIssue from analyzer\n    function: ParsedFunction from parser\n    docstring: Optional ParsedDocstring\n    project_style: Docstring style to use (default: \"google\")\n    **kwargs: Additional context parameters\n\nReturns:\n    Configured SuggestionContext instance",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 5,
      "quality_score": 4
    },
    {
      "function_name": "_build_analysis_prompt",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_build_analysis_prompt', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='function', type_annotation='Any', default_value=None, is_required=True), FunctionParameter(name='docstring', type_annotation='Any', default_value=None, is_required=True), FunctionParameter(name='analysis_types', type_annotation='list[str]', default_value=None, is_required=True), FunctionParameter(name='context', type_annotation='dict[str, Any]', default_value=None, is_required=True)], return_type='tuple[str, str]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Build optimized prompt for analysis type.\n\nArgs:\n    function: ParsedFunction object\n    docstring: ParsedDocstring object\n    analysis_types: List of analysis types to perform\n    context: Additional context (rule_results, related_functions, etc.)\n\nReturns:\n    Tuple of (system_prompt, user_prompt)",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "with_retry",
      "module_path": "codedocsync\\analyzer\\llm_errors.py",
      "function_signature": "FunctionSignature(name='with_retry', parameters=[FunctionParameter(name='func', type_annotation='Callable[..., T]', default_value=None, is_required=True), FunctionParameter(name='retry_strategy', type_annotation='RetryStrategy | None', default_value='None', is_required=False), FunctionParameter(name='*args', type_annotation='Any', default_value=None, is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type='T', is_async=True, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Execute function with retry logic.\n\nArgs:\n    func: Function to execute\n    retry_strategy: Retry strategy to use\n    *args: Positional arguments for function\n    **kwargs: Keyword arguments for function\n\nReturns:\n    Function result\n\nRaises:\n    Exception: Last exception if all retries fail",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "debug_prompt",
      "module_path": "codedocsync\\analyzer\\prompt_debug.py",
      "function_signature": "FunctionSignature(name='debug_prompt', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='analysis_type', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='function', type_annotation='ParsedFunction', default_value=None, is_required=True), FunctionParameter(name='docstring', type_annotation='ParsedDocstring', default_value=None, is_required=True), FunctionParameter(name='rule_issues', type_annotation='str | None', default_value='None', is_required=False), FunctionParameter(name='show_details', type_annotation='bool', default_value='True', is_required=False)], return_type='PromptAnalysis', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Debug a specific prompt template with sample data.\n\nArgs:\n    analysis_type: Type of analysis ('behavior_analysis', etc.)\n    function: Sample function to analyze\n    docstring: Sample docstring\n    rule_issues: Optional rule engine issues\n    show_details: Whether to print detailed analysis\n\nReturns:\n    PromptAnalysis with detailed metrics",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "generate_docstring_template",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='generate_docstring_template', parameters=[FunctionParameter(name='missing_params', type_annotation='list[FunctionParameter]', default_value=None, is_required=True), FunctionParameter(name='missing_return_type', type_annotation='str | None', default_value='None', is_required=False), FunctionParameter(name='missing_raises', type_annotation='list[str] | None', default_value='None', is_required=False)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Create template for missing documentation sections.\n\nArgs:\n    missing_params: Parameters that need documentation\n    missing_return_type: Return type that needs documentation\n    missing_raises: Exception types that need documentation\n\nReturns:\n    Formatted docstring template",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "match_project",
      "module_path": "codedocsync\\matcher\\unified_facade.py",
      "function_signature": "FunctionSignature(name='match_project', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='project_path', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='use_cache', type_annotation='bool', default_value='True', is_required=False), FunctionParameter(name='enable_semantic', type_annotation='bool', default_value='True', is_required=False), FunctionParameter(name='progress_callback', type_annotation='Callable[[str, int, int], None] | None', default_value='None', is_required=False)], return_type='EnhancedMatchResult', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform complete matching on a project with advanced monitoring.\n\nArgs:\n    project_path: Root directory of the project\n    use_cache: Whether to use cached parsing/embeddings\n    enable_semantic: Whether to use semantic matching\n    progress_callback: Optional callback for progress updates\n\nReturns:\n    Unified MatchResult with all matches and comprehensive metadata",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "convert_docstring",
      "module_path": "codedocsync\\suggestions\\converter.py",
      "function_signature": "FunctionSignature(name='convert_docstring', parameters=[FunctionParameter(name='docstring', type_annotation='ParsedDocstring', default_value=None, is_required=True), FunctionParameter(name='from_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='to_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convenience function to convert a single docstring.\n\nArgs:\n    docstring: Parsed docstring to convert\n    from_style: Source style\n    to_style: Target style\n    **kwargs: Additional conversion options\n\nReturns:\n    Converted docstring string",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "batch_convert_docstrings",
      "module_path": "codedocsync\\suggestions\\converter.py",
      "function_signature": "FunctionSignature(name='batch_convert_docstrings', parameters=[FunctionParameter(name='docstrings', type_annotation='list[ParsedDocstring]', default_value=None, is_required=True), FunctionParameter(name='from_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='to_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type='list[str | None]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convenience function to convert multiple docstrings.\n\nArgs:\n    docstrings: List of parsed docstrings\n    from_style: Source style\n    to_style: Target style\n    **kwargs: Additional conversion options\n\nReturns:\n    List of converted docstring strings",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "convert",
      "module_path": "codedocsync\\suggestions\\converter.py",
      "function_signature": "FunctionSignature(name='convert', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='docstring', type_annotation='ParsedDocstring', default_value=None, is_required=True), FunctionParameter(name='from_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='to_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='preserve_formatting', type_annotation='bool', default_value='True', is_required=False), FunctionParameter(name='max_line_length', type_annotation='int', default_value='88', is_required=False)], return_type='str', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convert parsed docstring to different style.\n\nArgs:\n    docstring: Parsed docstring to convert\n    from_style: Original docstring style\n    to_style: Target docstring style\n    preserve_formatting: Whether to preserve custom formatting\n    max_line_length: Maximum line length for the target style\n\nReturns:\n    Converted docstring as a formatted string\n\nRaises:\n    ValueError: If conversion between styles is not supported",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "convert_batch",
      "module_path": "codedocsync\\suggestions\\converter.py",
      "function_signature": "FunctionSignature(name='convert_batch', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='docstrings', type_annotation='list[ParsedDocstring]', default_value=None, is_required=True), FunctionParameter(name='from_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='to_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type='list[str | None]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convert multiple docstrings in batch.\n\nArgs:\n    docstrings: List of parsed docstrings to convert\n    from_style: Original docstring style\n    to_style: Target docstring style\n    **kwargs: Additional arguments passed to convert()\n\nReturns:\n    List of converted docstring strings",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "create_diff_preview",
      "module_path": "codedocsync\\suggestions\\__init__.py",
      "function_signature": "FunctionSignature(name='create_diff_preview', parameters=[FunctionParameter(name='original', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='suggested', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='filename', type_annotation='str', default_value=\"'docstring'\", is_required=False)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Create a unified diff preview between original and suggested text.\n\nArgs:\n    original: Original text\n    suggested: Suggested text\n    filename: Filename to use in diff headers\n\nReturns:\n    Unified diff string",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 4
    },
    {
      "function_name": "analyze_function",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='analyze_function', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True), FunctionParameter(name='cache', type_annotation='dict[str, Any] | None', default_value='None', is_required=False)], return_type='LLMAnalysisResponse', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform LLM analysis with caching and error handling.\n\nArgs:\n    request: LLM analysis request with function and docstring\n    cache: Optional analysis cache (reserved for future use)\n\nReturns:\n    LLMAnalysisResponse with structured results\n\nRaises:\n    ValueError: If request is invalid\n    openai.APIError: If API call fails after retries\n    asyncio.TimeoutError: If request times out",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "_call_openai",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_call_openai', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='user_prompt', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='system_prompt', type_annotation='str | None', default_value='None', is_required=False)], return_type='tuple[str, dict[str, int]]', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Make OpenAI API call with retry logic.\n\nArgs:\n    user_prompt: The main prompt for analysis\n    system_prompt: Optional system prompt for role definition\n\nReturns:\n    Tuple of (response_text, token_usage_dict)\n\nRaises:\n    openai.APIError: If API call fails after retries\n    asyncio.TimeoutError: If request times out",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "merge_with_rule_results",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='merge_with_rule_results', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='llm_issues', type_annotation='list[InconsistencyIssue]', default_value=None, is_required=True), FunctionParameter(name='rule_results', type_annotation='list[RuleCheckResult]', default_value=None, is_required=True)], return_type='list[InconsistencyIssue]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Merge LLM and rule engine results intelligently.\n\nArgs:\n    llm_issues: Issues found by LLM analysis\n    rule_results: Results from rule engine\n\nReturns:\n    Combined and deduplicated list of issues",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "_is_similar_issue",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_is_similar_issue', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='issue1', type_annotation='InconsistencyIssue', default_value=None, is_required=True), FunctionParameter(name='issue2', type_annotation='InconsistencyIssue', default_value=None, is_required=True)], return_type='bool', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Check if two issues are similar enough to be considered duplicates.\n\nArgs:\n    issue1: First issue to compare\n    issue2: Second issue to compare\n\nReturns:\n    True if issues are similar enough to merge",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "_create_error_response",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_create_error_response', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True), FunctionParameter(name='error_message', type_annotation='str', default_value=None, is_required=True)], return_type='LLMAnalysisResponse', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Create an error response for failed analysis.\n\nArgs:\n    request: Original request that failed\n    error_message: Error description\n\nReturns:\n    Error response with minimal information",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "_empty_analysis",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_empty_analysis', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True), FunctionParameter(name='error', type_annotation='Exception | None', default_value='None', is_required=False)], return_type='AnalysisResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Create empty analysis result when all strategies fail.\n\nArgs:\n    request: Original analysis request\n    error: Last error encountered\n\nReturns:\n    Empty AnalysisResult with error information",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "_llm_response_to_analysis_result",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_llm_response_to_analysis_result', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True), FunctionParameter(name='response', type_annotation='LLMAnalysisResponse', default_value=None, is_required=True)], return_type='AnalysisResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convert LLMAnalysisResponse to AnalysisResult.\n\nArgs:\n    request: Original request\n    response: LLM response\n\nReturns:\n    AnalysisResult with LLM data",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "should_retry",
      "module_path": "codedocsync\\analyzer\\llm_errors.py",
      "function_signature": "FunctionSignature(name='should_retry', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='error', type_annotation='Exception', default_value=None, is_required=True), FunctionParameter(name='attempt', type_annotation='int', default_value=None, is_required=True)], return_type='tuple[bool, float]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Determine if should retry and calculate delay.\n\nArgs:\n    error: The exception that occurred\n    attempt: Current attempt number (0-based)\n\nReturns:\n    Tuple of (should_retry, delay_seconds)",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "_calculate_delay",
      "module_path": "codedocsync\\analyzer\\llm_errors.py",
      "function_signature": "FunctionSignature(name='_calculate_delay', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='attempt', type_annotation='int', default_value=None, is_required=True), FunctionParameter(name='retry_after', type_annotation='float | None', default_value='None', is_required=False)], return_type='float', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Calculate delay for retry attempt.\n\nArgs:\n    attempt: Current attempt number (0-based)\n    retry_after: Explicit retry delay from error (e.g., Retry-After header)\n\nReturns:\n    Delay in seconds",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "call",
      "module_path": "codedocsync\\analyzer\\llm_errors.py",
      "function_signature": "FunctionSignature(name='call', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='func', type_annotation='Callable[..., T]', default_value=None, is_required=True), FunctionParameter(name='*args', type_annotation='Any', default_value=None, is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type='T', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Execute function with circuit breaker protection.\n\nArgs:\n    func: Function to execute\n    *args: Positional arguments for function\n    **kwargs: Keyword arguments for function\n\nReturns:\n    Function result\n\nRaises:\n    LLMError: If circuit is open or function fails",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "parse_llm_response",
      "module_path": "codedocsync\\analyzer\\llm_output_parser.py",
      "function_signature": "FunctionSignature(name='parse_llm_response', parameters=[FunctionParameter(name='raw_response', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='strict', type_annotation='bool', default_value='True', is_required=False)], return_type='ParseResult', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Parse a single LLM response.\n\nArgs:\n    raw_response: Raw text response from LLM\n    strict: Whether to use strict validation\n\nReturns:\n    ParseResult with parsed issues",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "parse_and_filter_response",
      "module_path": "codedocsync\\analyzer\\llm_output_parser.py",
      "function_signature": "FunctionSignature(name='parse_and_filter_response', parameters=[FunctionParameter(name='raw_response', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='filter_actionable', type_annotation='bool', default_value='True', is_required=False)], return_type='list[InconsistencyIssue]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Parse response and return filtered list of actionable issues.\n\nArgs:\n    raw_response: Raw text response from LLM\n    filter_actionable: Whether to filter out non-actionable suggestions\n\nReturns:\n    List of validated InconsistencyIssue objects",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "validate_response_format",
      "module_path": "codedocsync\\analyzer\\llm_output_parser.py",
      "function_signature": "FunctionSignature(name='validate_response_format', parameters=[FunctionParameter(name='response_data', type_annotation='dict[str, Any]', default_value=None, is_required=True)], return_type='tuple[bool, str]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Validate LLM response format without full parsing.\n\nArgs:\n    response_data: Parsed JSON response\n\nReturns:\n    Tuple of (is_valid, error_message)",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "parse_analysis_response",
      "module_path": "codedocsync\\analyzer\\llm_output_parser.py",
      "function_signature": "FunctionSignature(name='parse_analysis_response', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='raw_response', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='expected_format', type_annotation='str', default_value=\"'json'\", is_required=False)], return_type='ParseResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Parse LLM response into structured issues.\n\nArgs:\n    raw_response: Raw text response from LLM\n    expected_format: Expected format ('json' is only supported format)\n\nReturns:\n    ParseResult with parsed issues or error information",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "test_response_parsing",
      "module_path": "codedocsync\\analyzer\\prompt_debug.py",
      "function_signature": "FunctionSignature(name='test_response_parsing', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='sample_responses', type_annotation='list[str]', default_value=None, is_required=True), FunctionParameter(name='show_details', type_annotation='bool', default_value='True', is_required=False)], return_type='dict[str, Any]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Test LLM response parsing with sample responses.\n\nArgs:\n    sample_responses: List of sample LLM responses to test\n    show_details: Whether to show detailed results\n\nReturns:\n    Dictionary with parsing statistics and results",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "validate_prompt_token_usage",
      "module_path": "codedocsync\\analyzer\\prompt_debug.py",
      "function_signature": "FunctionSignature(name='validate_prompt_token_usage', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True), FunctionParameter(name='max_tokens', type_annotation='int', default_value='4000', is_required=False)], return_type='dict[str, Any]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Validate that a request fits within token limits.\n\nArgs:\n    request: LLM analysis request to validate\n    max_tokens: Maximum allowed tokens\n\nReturns:\n    Validation results with recommendations",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "get_prompt_template",
      "module_path": "codedocsync\\analyzer\\prompt_templates.py",
      "function_signature": "FunctionSignature(name='get_prompt_template', parameters=[FunctionParameter(name='analysis_type', type_annotation='str', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get a prompt template for a specific analysis type.\n\nArgs:\n    analysis_type: Type of analysis ('behavior_analysis', 'example_validation', etc.)\n\nReturns:\n    str: The prompt template\n\nRaises:\n    ValueError: If analysis_type is not supported",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "validate_llm_response",
      "module_path": "codedocsync\\analyzer\\prompt_templates.py",
      "function_signature": "FunctionSignature(name='validate_llm_response', parameters=[FunctionParameter(name='response_data', type_annotation='Any', default_value=None, is_required=True)], return_type='bool', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Validate that an LLM response has the expected structure.\n\nArgs:\n    response_data: Parsed JSON response from LLM\n\nReturns:\n    bool: True if response has valid structure",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "map_llm_issue_type",
      "module_path": "codedocsync\\analyzer\\prompt_templates.py",
      "function_signature": "FunctionSignature(name='map_llm_issue_type', parameters=[FunctionParameter(name='llm_type', type_annotation='str', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Map LLM-specific issue types to our standard issue types.\n\nArgs:\n    llm_type: Issue type from LLM response\n\nReturns:\n    str: Mapped issue type from our ISSUE_TYPES constants",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "check_matched_pair",
      "module_path": "codedocsync\\analyzer\\rule_engine.py",
      "function_signature": "FunctionSignature(name='check_matched_pair', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='pair', type_annotation='MatchedPair', default_value=None, is_required=True), FunctionParameter(name='confidence_threshold', type_annotation='float', default_value='0.9', is_required=False)], return_type='list[InconsistencyIssue]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Main entry point for rule checking.\n\nArgs:\n    pair: The matched function-documentation pair to analyze\n    confidence_threshold: Minimum confidence to skip LLM analysis\n\nReturns:\n    List of detected inconsistency issues",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "normalize_type_string",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='normalize_type_string', parameters=[FunctionParameter(name='type_str', type_annotation='str', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convert type string variations to canonical form.\n\nArgs:\n    type_str: Type string to normalize\n\nReturns:\n    Normalized type string",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "compare_types",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='compare_types', parameters=[FunctionParameter(name='type1', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='type2', type_annotation='str', default_value=None, is_required=True)], return_type='bool', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Check if two type strings are equivalent.\n\nArgs:\n    type1: First type string\n    type2: Second type string\n\nReturns:\n    True if types are equivalent",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "extract_base_type",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='extract_base_type', parameters=[FunctionParameter(name='type_str', type_annotation='str', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get base type from Optional, List, etc.\n\nArgs:\n    type_str: Type string to extract from\n\nReturns:\n    Base type string",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "extract_function_params",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='extract_function_params', parameters=[FunctionParameter(name='function', type_annotation='ParsedFunction', default_value=None, is_required=True)], return_type='list[FunctionParameter]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get parameters from FunctionSignature, excluding self/cls.\n\nArgs:\n    function: Parsed function to extract from\n\nReturns:\n    List of function parameters (excluding self/cls)",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "extract_doc_params",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='extract_doc_params', parameters=[FunctionParameter(name='docstring', type_annotation='ParsedDocstring | None', default_value=None, is_required=True)], return_type='list[DocstringParameter]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get parameters from ParsedDocstring.\n\nArgs:\n    docstring: Parsed docstring to extract from\n\nReturns:\n    List of documented parameters",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "should_ignore_param",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='should_ignore_param', parameters=[FunctionParameter(name='param_name', type_annotation='str', default_value=None, is_required=True)], return_type='bool', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Check if parameter should be skipped in analysis.\n\nArgs:\n    param_name: Parameter name to check\n\nReturns:\n    True if parameter should be ignored",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "get_param_mapping",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='get_param_mapping', parameters=[FunctionParameter(name='func_params', type_annotation='list[FunctionParameter]', default_value=None, is_required=True), FunctionParameter(name='doc_params', type_annotation='list[DocstringParameter]', default_value=None, is_required=True)], return_type='tuple[dict[str, FunctionParameter], dict[str, DocstringParameter]]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Create name-to-parameter mappings for comparison.\n\nArgs:\n    func_params: Function parameters\n    doc_params: Documentation parameters\n\nReturns:\n    Tuple of (func_mapping, doc_mapping)",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "format_code_suggestion",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='format_code_suggestion', parameters=[FunctionParameter(name='suggestion', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='language', type_annotation='str', default_value=\"'python'\", is_required=False)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Format suggestions as markdown code blocks.\n\nArgs:\n    suggestion: Raw suggestion text\n    language: Programming language for syntax highlighting\n\nReturns:\n    Markdown-formatted suggestion",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "get_parameter_statistics",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='get_parameter_statistics', parameters=[FunctionParameter(name='func_params', type_annotation='list[FunctionParameter]', default_value=None, is_required=True), FunctionParameter(name='doc_params', type_annotation='list[DocstringParameter]', default_value=None, is_required=True)], return_type='dict[str, Any]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Generate statistics about parameter documentation coverage.\n\nArgs:\n    func_params: Function parameters\n    doc_params: Documentation parameters\n\nReturns:\n    Dictionary with coverage statistics",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "validate_special_parameters",
      "module_path": "codedocsync\\analyzer\\rule_engine_utils.py",
      "function_signature": "FunctionSignature(name='validate_special_parameters', parameters=[FunctionParameter(name='func_params', type_annotation='list[FunctionParameter]', default_value=None, is_required=True)], return_type='list[dict[str, Any]]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Validate special parameter patterns (*args, **kwargs, Optional types).\n\nArgs:\n    func_params: Function parameters to validate\n\nReturns:\n    List of validation issues found",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "match_project",
      "module_path": "codedocsync\\matcher\\contextual_facade.py",
      "function_signature": "FunctionSignature(name='match_project', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='project_path', type_annotation='str | Path', default_value=None, is_required=True), FunctionParameter(name='use_cache', type_annotation='bool', default_value='True', is_required=False)], return_type='MatchResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform complete matching on a project.\n\nArgs:\n    project_path: Root directory of the project\n    use_cache: Whether to use cached parsing results\n\nReturns:\n    Combined MatchResult with all matches",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "match_file",
      "module_path": "codedocsync\\matcher\\contextual_facade.py",
      "function_signature": "FunctionSignature(name='match_file', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='file_path', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='project_path', type_annotation='str | None', default_value='None', is_required=False)], return_type='MatchResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Match a single file with optional project context.\n\nArgs:\n    file_path: Python file to analyze\n    project_path: Optional project root for context\n\nReturns:\n    MatchResult for the file",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "match_with_context",
      "module_path": "codedocsync\\matcher\\contextual_matcher.py",
      "function_signature": "FunctionSignature(name='match_with_context', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='functions', type_annotation='list[ParsedFunction]', default_value=None, is_required=True), FunctionParameter(name='direct_match_result', type_annotation='MatchResult | None', default_value='None', is_required=False)], return_type='MatchResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform contextual matching on functions.\n\nArgs:\n    functions: Functions to match (with their docstrings)\n    direct_match_result: Previous direct matching results to enhance\n\nReturns:\n    MatchResult with contextual matches",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "find_related_docs",
      "module_path": "codedocsync\\matcher\\doc_location_finder.py",
      "function_signature": "FunctionSignature(name='find_related_docs', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='function_name', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='module_path', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='search_radius', type_annotation='int', default_value='2', is_required=False)], return_type='list[tuple[str, ParsedDocstring]]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Search for documentation in related files.\n\nArgs:\n    function_name: Name of the function\n    module_path: Current module path\n    search_radius: How many directories up to search\n\nReturns:\n    List of (file_path, docstring) tuples",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "find_function",
      "module_path": "codedocsync\\matcher\\function_registry.py",
      "function_signature": "FunctionSignature(name='find_function', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='name', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='hint_module', type_annotation='str | None', default_value='None', is_required=False)], return_type='list[FunctionLocation]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Find functions by name, optionally with module hint.\n\nArgs:\n    name: Function name to search for\n    hint_module: Optional module to prioritize\n\nReturns:\n    List of matching functions, sorted by relevance",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "resolve_import",
      "module_path": "codedocsync\\matcher\\module_resolver.py",
      "function_signature": "FunctionSignature(name='resolve_import', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='import_stmt', type_annotation='ImportStatement', default_value=None, is_required=True), FunctionParameter(name='current_module', type_annotation='str', default_value=None, is_required=True)], return_type='str | None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Resolve an import statement to absolute module path.\n\nArgs:\n    import_stmt: The import statement to resolve\n    current_module: The module containing the import\n\nReturns:\n    Absolute module path or None if can't resolve",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "create_circuit_breaker",
      "module_path": "codedocsync\\matcher\\semantic_error_recovery.py",
      "function_signature": "FunctionSignature(name='create_circuit_breaker', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='failure_threshold', type_annotation='int', default_value='5', is_required=False), FunctionParameter(name='recovery_time', type_annotation='float', default_value='60.0', is_required=False)], return_type=\"'CircuitBreaker'\", is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Create a circuit breaker for protecting against cascading failures.\n\nArgs:\n    failure_threshold: Number of consecutive failures before opening circuit\n    recovery_time: Time to wait before allowing requests again\n\nReturns:\n    CircuitBreaker instance",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "prepare_semantic_index",
      "module_path": "codedocsync\\matcher\\semantic_matcher.py",
      "function_signature": "FunctionSignature(name='prepare_semantic_index', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='all_functions', type_annotation='list[ParsedFunction]', default_value=None, is_required=True), FunctionParameter(name='force_reindex', type_annotation='bool', default_value='False', is_required=False)], return_type='None', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Prepare the semantic search index with all functions.\n\nThis should be called once before matching to build the index.\nThis method processes all functions and creates embeddings for semantic search.\n\nArgs:\n    all_functions: List of functions to index\n    force_reindex: If True, regenerate all embeddings even if cached",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "match_with_embeddings",
      "module_path": "codedocsync\\matcher\\semantic_matcher.py",
      "function_signature": "FunctionSignature(name='match_with_embeddings', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='functions', type_annotation='list[ParsedFunction]', default_value=None, is_required=True), FunctionParameter(name='previous_results', type_annotation='list[MatchResult] | None', default_value='None', is_required=False)], return_type='MatchResult', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform semantic matching on functions.\n\nArgs:\n    functions: Functions to find matches for\n    previous_results: Results from direct/contextual matching\n\nReturns:\n    MatchResult with semantic matches added",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "calculate_semantic_confidence",
      "module_path": "codedocsync\\matcher\\semantic_scorer.py",
      "function_signature": "FunctionSignature(name='calculate_semantic_confidence', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='similarity_score', type_annotation='float', default_value=None, is_required=True), FunctionParameter(name='source_function', type_annotation='ParsedFunction', default_value=None, is_required=True), FunctionParameter(name='validation_context', type_annotation='dict | None', default_value='None', is_required=False)], return_type='MatchConfidence', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Calculate confidence scores for semantic match.\n\nArgs:\n    similarity_score: Adjusted similarity score after validation\n    source_function: Source function being matched\n    validation_context: Optional context from validation process\n\nReturns:\n    MatchConfidence with appropriate scores for semantic matching",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "_calculate_name_similarity",
      "module_path": "codedocsync\\matcher\\semantic_scorer.py",
      "function_signature": "FunctionSignature(name='_calculate_name_similarity', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='name1', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='name2', type_annotation='str', default_value=None, is_required=True)], return_type='float', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Calculate simple name similarity using character overlap.\n\nArgs:\n    name1: First function name\n    name2: Second function name\n\nReturns:\n    Similarity score between 0.0 and 1.0",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "_calculate_module_distance",
      "module_path": "codedocsync\\matcher\\semantic_scorer.py",
      "function_signature": "FunctionSignature(name='_calculate_module_distance', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='module1', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='module2', type_annotation='str', default_value=None, is_required=True)], return_type='int', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Calculate distance between modules based on their paths.\n\nArgs:\n    module1: First module path (e.g., 'src.utils.helpers')\n    module2: Second module path (e.g., 'src.core.main')\n\nReturns:\n    Distance as number of levels between modules",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "assess_match_quality",
      "module_path": "codedocsync\\matcher\\semantic_scorer.py",
      "function_signature": "FunctionSignature(name='assess_match_quality', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='source_function', type_annotation='ParsedFunction', default_value=None, is_required=True), FunctionParameter(name='similarity_score', type_annotation='float', default_value=None, is_required=True), FunctionParameter(name='additional_context', type_annotation='dict | None', default_value='None', is_required=False)], return_type='dict', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Assess overall match quality with detailed breakdown.\n\nArgs:\n    source_function: Function being matched\n    similarity_score: Semantic similarity score\n    additional_context: Optional additional validation context\n\nReturns:\n    Dictionary with detailed quality assessment",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "get",
      "module_path": "codedocsync\\storage\\embedding_cache.py",
      "function_signature": "FunctionSignature(name='get', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='text', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='model', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='signature_hash', type_annotation='str | None', default_value='None', is_required=False)], return_type='FunctionEmbedding | None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get embedding from cache.\n\nArgs:\n    text: Text that was embedded\n    model: Model used for embedding\n    signature_hash: Optional hash to verify function hasn't changed\n\nReturns:\n    FunctionEmbedding if found and valid, None otherwise",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "estimate_conversion_quality",
      "module_path": "codedocsync\\suggestions\\converter.py",
      "function_signature": "FunctionSignature(name='estimate_conversion_quality', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='docstring', type_annotation='ParsedDocstring', default_value=None, is_required=True), FunctionParameter(name='from_style', type_annotation='DocstringStyle', default_value=None, is_required=True), FunctionParameter(name='to_style', type_annotation='DocstringStyle', default_value=None, is_required=True)], return_type='dict[str, Any]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Estimate the quality of conversion between styles.\n\nArgs:\n    docstring: Docstring to analyze\n    from_style: Source style\n    to_style: Target style\n\nReturns:\n    Dictionary with quality metrics and warnings",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "create_fallback_suggestion",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='create_fallback_suggestion', parameters=[FunctionParameter(name='context', type_annotation='SuggestionContext', default_value=None, is_required=True), FunctionParameter(name='error', type_annotation='Exception | None', default_value='None', is_required=False)], return_type='Suggestion', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Create a fallback suggestion when generation fails.\n\nArgs:\n    context: Suggestion context\n    error: Error that caused the fallback\n\nReturns:\n    Basic suggestion with low confidence",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "with_suggestion_fallback",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='with_suggestion_fallback', parameters=[FunctionParameter(name='fallback_func', type_annotation='Callable[[SuggestionContext], Suggestion] | None', default_value='None', is_required=False)], return_type='Callable', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Decorator for graceful degradation in suggestion generation.\n\nArgs:\n    fallback_func: Optional custom fallback function\n\nReturns:\n    Decorated function",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "handle_suggestion_error",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='handle_suggestion_error', parameters=[FunctionParameter(name='error', type_annotation='Exception', default_value=None, is_required=True), FunctionParameter(name='context', type_annotation='SuggestionContext | None', default_value='None', is_required=False)], return_type='Suggestion | None', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Handle a suggestion error using global handler.\n\nArgs:\n    error: Error that occurred\n    context: Context when error occurred\n\nReturns:\n    Recovery suggestion if possible, None otherwise",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "should_retry",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='should_retry', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='error', type_annotation='Exception', default_value=None, is_required=True), FunctionParameter(name='attempt', type_annotation='int', default_value=None, is_required=True)], return_type='bool', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Determine if operation should be retried.\n\nArgs:\n    error: Error that occurred\n    attempt: Current attempt number\n\nReturns:\n    True if should retry",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "handle_error",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='handle_error', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='error', type_annotation='Exception', default_value=None, is_required=True), FunctionParameter(name='context', type_annotation='SuggestionContext | None', default_value='None', is_required=False)], return_type='Suggestion | None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Handle an error and attempt recovery.\n\nArgs:\n    error: Error that occurred\n    context: Context when error occurred\n\nReturns:\n    Recovery suggestion if possible, None otherwise",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "measure_performance",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='measure_performance', parameters=[FunctionParameter(name='operation', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='**metadata', type_annotation='Any', default_value=None, is_required=False)], return_type='Iterator[None]', is_async=False, is_method=False, decorators=['contextmanager'])",
      "docstring_format": "google",
      "docstring_content": "Measure performance using global monitor.\n\nArgs:\n    operation: Operation name\n    **metadata: Additional metadata\n\nYields:\n    None",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "should_batch",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='should_batch', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='operation', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='item_count', type_annotation='int', default_value=None, is_required=True)], return_type='bool', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Determine if operations should be batched.\n\nArgs:\n    operation: Operation type\n    item_count: Number of items to process\n\nReturns:\n    True if batching recommended",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "format_type_for_style",
      "module_path": "codedocsync\\suggestions\\type_formatter.py",
      "function_signature": "FunctionSignature(name='format_type_for_style', parameters=[FunctionParameter(name='type_annotation', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='style', type_annotation='DocstringStyle', default_value='DocstringStyle.GOOGLE', is_required=False)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convenience function to format a type annotation for a specific style.\n\nArgs:\n    type_annotation: Type annotation to format\n    style: Target docstring style\n\nReturns:\n    Formatted type string",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "extract_type_from_ast",
      "module_path": "codedocsync\\suggestions\\type_formatter.py",
      "function_signature": "FunctionSignature(name='extract_type_from_ast', parameters=[FunctionParameter(name='node', type_annotation='ast.AST', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convenience function to extract type from AST node.\n\nArgs:\n    node: AST node containing type information\n\nReturns:\n    String representation of the type",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "validate_suggestion_quality",
      "module_path": "codedocsync\\suggestions\\__init__.py",
      "function_signature": "FunctionSignature(name='validate_suggestion_quality', parameters=[FunctionParameter(name='suggestion', type_annotation='Suggestion', default_value=None, is_required=True)], return_type='dict[str, Any]', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Validate and analyze the quality of a suggestion.\n\nArgs:\n    suggestion: Suggestion to validate\n\nReturns:\n    Dictionary with quality metrics and validation results",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "detect_project_style",
      "module_path": "codedocsync\\suggestions\\__init__.py",
      "function_signature": "FunctionSignature(name='detect_project_style', parameters=[FunctionParameter(name='project_path', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='config', type_annotation='SuggestionConfig | None', default_value='None', is_required=False)], return_type='str', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Detect the predominant docstring style in a project.\n\nArgs:\n    project_path: Path to the project directory\n    config: Optional configuration for detection\n\nReturns:\n    Detected style name (\"google\", \"numpy\", \"sphinx\", or \"rest\")",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 4
    },
    {
      "function_name": "acquire",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='acquire', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='tokens', type_annotation='int', default_value='1', is_required=False)], return_type='bool', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Attempt to acquire tokens from the bucket.\n\nArgs:\n    tokens: Number of tokens to acquire\n\nReturns:\n    True if tokens were acquired, False otherwise",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "_estimate_function_complexity",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_estimate_function_complexity', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='function', type_annotation=\"'ParsedFunction'\", default_value=None, is_required=True)], return_type='int', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Estimate function complexity for prioritization.\n\nArgs:\n    function: Function to analyze\n\nReturns:\n    Complexity score (higher = more complex)",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "_analyze_with_llm",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='_analyze_with_llm', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='request', type_annotation='LLMAnalysisRequest', default_value=None, is_required=True)], return_type='AnalysisResult', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform full LLM analysis with circuit breaker protection.\n\nArgs:\n    request: LLM analysis request\n\nReturns:\n    AnalysisResult from LLM analysis\n\nRaises:\n    LLMError: If circuit breaker is open or analysis fails",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "get",
      "module_path": "codedocsync\\analyzer\\llm_cache.py",
      "function_signature": "FunctionSignature(name='get', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='cache_key', type_annotation='str', default_value=None, is_required=True)], return_type='LLMAnalysisResponse | None', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get cached response with freshness check.\n\nArgs:\n    cache_key: Unique cache key for the request\n\nReturns:\n    Cached response if found and valid, None otherwise",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "invalidate_by_file",
      "module_path": "codedocsync\\analyzer\\llm_cache.py",
      "function_signature": "FunctionSignature(name='invalidate_by_file', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='file_path', type_annotation='str', default_value=None, is_required=True)], return_type='int', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Invalidate cache entries for a specific file.\n\nArgs:\n    file_path: Path to the file whose cache entries should be invalidated\n\nReturns:\n    Number of entries invalidated",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "estimate_cost_usd",
      "module_path": "codedocsync\\analyzer\\llm_models.py",
      "function_signature": "FunctionSignature(name='estimate_cost_usd', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='model_pricing', type_annotation='dict[str, float] | None', default_value='None', is_required=False)], return_type='float', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Estimate the cost of this API call in USD.\n\nArgs:\n    model_pricing: Optional pricing per 1K tokens for different models\n                  If None, uses default pricing estimates\n\nReturns:\n    Estimated cost in USD",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "validate_issue_actionability",
      "module_path": "codedocsync\\analyzer\\llm_output_parser.py",
      "function_signature": "FunctionSignature(name='validate_issue_actionability', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='issue', type_annotation='InconsistencyIssue', default_value=None, is_required=True)], return_type='bool', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Check if an issue suggestion is actionable (not vague).\n\nArgs:\n    issue: Issue to validate\n\nReturns:\n    True if suggestion is actionable, False if too vague",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "get_alerts",
      "module_path": "codedocsync\\analyzer\\llm_performance.py",
      "function_signature": "FunctionSignature(name='get_alerts', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='since', type_annotation='float | None', default_value='None', is_required=False)], return_type='list[PerformanceAlert]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get performance alerts.\n\nArgs:\n    since: Unix timestamp to get alerts since (optional)\n\nReturns:\n    List of performance alerts",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "analyze_project",
      "module_path": "codedocsync\\matcher\\contextual_matcher.py",
      "function_signature": "FunctionSignature(name='analyze_project', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='python_files', type_annotation='list[str] | None', default_value='None', is_required=False)], return_type='ContextualMatcherState', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Analyze all Python files to build project context.\n\nArgs:\n    python_files: Optional list of files, otherwise discover all\n\nReturns:\n    Populated ContextualMatcherState",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "match_project",
      "module_path": "codedocsync\\matcher\\facade.py",
      "function_signature": "FunctionSignature(name='match_project', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='project_path', type_annotation='str | Path', default_value=None, is_required=True)], return_type='MatchResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Parse and match all Python files in a project.\n\nArgs:\n    project_path: Root directory of project\n\nReturns:\n    Combined MatchResult for entire project",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "analyze_error",
      "module_path": "codedocsync\\matcher\\semantic_error_recovery.py",
      "function_signature": "FunctionSignature(name='analyze_error', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='error', type_annotation='Exception', default_value=None, is_required=True)], return_type='ErrorAnalysis', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Analyze an error and determine the appropriate recovery strategy.\n\nArgs:\n    error: The exception that occurred\n\nReturns:\n    ErrorAnalysis with recommended recovery action",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "get_embedding_for_function",
      "module_path": "codedocsync\\matcher\\semantic_matcher.py",
      "function_signature": "FunctionSignature(name='get_embedding_for_function', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='function', type_annotation='ParsedFunction', default_value=None, is_required=True)], return_type='FunctionEmbedding | None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get cached embedding for a specific function.\n\nArgs:\n    function: Function to get embedding for\n\nReturns:\n    FunctionEmbedding if cached, None otherwise",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "match_file",
      "module_path": "codedocsync\\matcher\\unified_facade.py",
      "function_signature": "FunctionSignature(name='match_file', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='file_path', type_annotation='str | Path', default_value=None, is_required=True)], return_type='MatchResult', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Match functions in a single file using the unified pipeline.\n\nArgs:\n    file_path: Path to Python file\n\nReturns:\n    MatchResult with matched pairs",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "parse_batch",
      "module_path": "codedocsync\\parser\\docstring_parser.py",
      "function_signature": "FunctionSignature(name='parse_batch', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='docstrings', type_annotation='list[str | None]', default_value=None, is_required=True)], return_type='list[ParsedDocstring | None]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Parse multiple docstrings efficiently using thread pool.\n\nArgs:\n    docstrings: List of docstring texts to parse\n\nReturns:\n    List of parsed docstrings in the same order as input",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "parse_file_lazy",
      "module_path": "codedocsync\\parser\\integrated_parser.py",
      "function_signature": "FunctionSignature(name='parse_file_lazy', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='file_path', type_annotation='str', default_value=None, is_required=True)], return_type='Generator[ParsedFunction, None, None]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Generator version for memory efficiency.\n\nArgs:\n    file_path: Path to Python file to parse\n\nYields:\n    ParsedFunction objects with enriched docstrings\n\nRaises:\n    FileNotFoundError: If file does not exist\n    ParsingError: If parsing fails",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "get_fallback_style",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='get_fallback_style', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='attempted_styles', type_annotation='list[str]', default_value=None, is_required=True)], return_type='str | None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get next fallback style to try.\n\nArgs:\n    attempted_styles: Styles already attempted\n\nReturns:\n    Next style to try, or None",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "get_stats",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='get_stats', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='operation', type_annotation='str | None', default_value='None', is_required=False)], return_type='dict[str, PerformanceStats]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get performance statistics.\n\nArgs:\n    operation: Specific operation to get stats for, or None for all\n\nReturns:\n    Dictionary of operation names to performance stats",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "get_slow_operations",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='get_slow_operations', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='limit', type_annotation='int', default_value='10', is_required=False)], return_type='list[tuple[str, PerformanceMetric]]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get slowest operations.\n\nArgs:\n    limit: Maximum number of operations to return\n\nReturns:\n    List of (operation_name, metric) tuples",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "should_use_cache",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='should_use_cache', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='operation', type_annotation='str', default_value=None, is_required=True)], return_type='bool', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Determine if operation should use caching.\n\nArgs:\n    operation: Operation to check\n\nReturns:\n    True if caching recommended",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "get_timeout",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='get_timeout', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='operation', type_annotation='str', default_value=None, is_required=True)], return_type='float', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Get recommended timeout for operation.\n\nArgs:\n    operation: Operation to get timeout for\n\nReturns:\n    Timeout in seconds",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "format_for_docstring",
      "module_path": "codedocsync\\suggestions\\type_formatter.py",
      "function_signature": "FunctionSignature(name='format_for_docstring', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='type_annotation', type_annotation='str', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Convert type annotation to docstring format.\n\nArgs:\n    type_annotation: Raw type annotation string\n\nReturns:\n    Formatted type string appropriate for the docstring style",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "extract_from_ast",
      "module_path": "codedocsync\\suggestions\\type_formatter.py",
      "function_signature": "FunctionSignature(name='extract_from_ast', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='node', type_annotation='ast.AST | None', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Extract type annotation from AST node.\n\nArgs:\n    node: AST node containing type annotation\n\nReturns:\n    String representation of the type",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "simplify_for_style",
      "module_path": "codedocsync\\suggestions\\type_formatter.py",
      "function_signature": "FunctionSignature(name='simplify_for_style', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='type_annotation', type_annotation='str', default_value=None, is_required=True)], return_type='str', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Simplify complex types for better readability in docstrings.\n\nArgs:\n    type_annotation: Type annotation to simplify\n\nReturns:\n    Simplified type string",
      "has_params": true,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "render_parameters",
      "module_path": "codedocsync\\suggestions\\templates\\numpy_template.py",
      "function_signature": "FunctionSignature(name='render_parameters', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='parameters', type_annotation='list[DocstringParameter]', default_value=None, is_required=True)], return_type='list[str]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "numpy",
      "docstring_content": "Render parameters in NumPy style.\n\nNumPy style uses underlined headers and specific spacing:\n\nParameters\n----------\nparam_name : type\n    Description of parameter that can span\n    multiple lines with consistent indent.",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "render_parameters",
      "module_path": "codedocsync\\suggestions\\templates\\sphinx_template.py",
      "function_signature": "FunctionSignature(name='render_parameters', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='parameters', type_annotation='list[DocstringParameter]', default_value=None, is_required=True)], return_type='list[str]', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "sphinx",
      "docstring_content": "Render parameters in Sphinx style.\n\nSphinx uses field lists with colons:\n\n:param param_name: Description of parameter\n:type param_name: str\n:param another: Description\n:type another: int, optional",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 4
    },
    {
      "function_name": "analyze",
      "module_path": "codedocsync\\cli\\analyze.py",
      "function_signature": "FunctionSignature(name='analyze', parameters=[FunctionParameter(name='path', type_annotation=\"Annotated[Path, typer.Argument(help='File or directory to analyze for documentation inconsistencies')]\", default_value=\"Path('.')\", is_required=False), FunctionParameter(name='rules_only', type_annotation=\"Annotated[bool, typer.Option('--rules-only', help='Skip LLM analysis, use only rule engine')]\", default_value='False', is_required=False), FunctionParameter(name='no_semantic', type_annotation=\"Annotated[bool, typer.Option('--no-semantic', help='Disable semantic matching (uses only direct/contextual matching)')]\", default_value='False', is_required=False), FunctionParameter(name='confidence_threshold', type_annotation=\"Annotated[float, typer.Option('--confidence-threshold', help='Confidence threshold for LLM routing')]\", default_value='0.9', is_required=False), FunctionParameter(name='cache_dir', type_annotation=\"Annotated[Path | None, typer.Option('--cache-dir', help='Directory for analysis cache')]\", default_value='None', is_required=False), FunctionParameter(name='parallel', type_annotation=\"Annotated[bool, typer.Option('--parallel/--sequential', help='Use parallel analysis')]\", default_value='True', is_required=False), FunctionParameter(name='output_format', type_annotation=\"Annotated[str, typer.Option('--format', '-f', help='Output format (terminal/json)')]\", default_value=\"'terminal'\", is_required=False), FunctionParameter(name='output_file', type_annotation=\"Annotated[Path | None, typer.Option('--output', '-o', help='Output file path')]\", default_value='None', is_required=False), FunctionParameter(name='config_profile', type_annotation=\"Annotated[str, typer.Option('--profile', help='Analysis profile (fast/thorough/development)')]\", default_value=\"'development'\", is_required=False), FunctionParameter(name='show_summary', type_annotation=\"Annotated[bool, typer.Option('--summary/--no-summary', help='Show analysis summary')]\", default_value='True', is_required=False), FunctionParameter(name='verbose', type_annotation=\"Annotated[bool, typer.Option('--verbose', '-v', help='Verbose output')]\", default_value='False', is_required=False)], return_type='None', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Analyze code for documentation inconsistencies using rules and LLM.\n\nThis command performs comprehensive analysis of function-documentation pairs\nto identify inconsistencies, missing documentation, and outdated descriptions.\n\nExamples:\n    codedocsync analyze ./src --rules-only\n    codedocsync analyze ./project --profile thorough --format json\n    codedocsync analyze ./src --no-semantic  # Without ChromaDB/semantic matching",
      "has_params": false,
      "has_returns": false,
      "has_examples": true,
      "complexity_score": 5,
      "quality_score": 3
    },
    {
      "function_name": "analyze_function",
      "module_path": "codedocsync\\cli\\analyze.py",
      "function_signature": "FunctionSignature(name='analyze_function', parameters=[FunctionParameter(name='file', type_annotation=\"Annotated[Path, typer.Argument(help='Python file containing the function')]\", default_value=None, is_required=True), FunctionParameter(name='function_name', type_annotation=\"Annotated[str, typer.Argument(help='Name of the function to analyze')]\", default_value=None, is_required=True), FunctionParameter(name='verbose', type_annotation=\"Annotated[bool, typer.Option('--verbose', '-v', help='Show detailed analysis')]\", default_value='False', is_required=False), FunctionParameter(name='rules_only', type_annotation=\"Annotated[bool, typer.Option('--rules-only', help='Skip LLM analysis')]\", default_value='False', is_required=False), FunctionParameter(name='no_semantic', type_annotation=\"Annotated[bool, typer.Option('--no-semantic', help='Disable semantic matching')]\", default_value='False', is_required=False), FunctionParameter(name='config_profile', type_annotation=\"Annotated[str, typer.Option('--profile', help='Analysis profile (fast/thorough/development)')]\", default_value=\"'development'\", is_required=False)], return_type='None', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Analyze a specific function in detail.\n\nThis command analyzes a single function and its documentation,\nproviding detailed insights and suggestions for improvement.\n\nExamples:\n    codedocsync analyze-function ./myfile.py process_user --verbose\n    codedocsync analyze-function ./src/utils.py validate_data --rules-only\n    codedocsync analyze-function ./myfile.py my_func --no-semantic",
      "has_params": false,
      "has_returns": false,
      "has_examples": true,
      "complexity_score": 5,
      "quality_score": 3
    },
    {
      "function_name": "match_contextual",
      "module_path": "codedocsync\\cli\\match.py",
      "function_signature": "FunctionSignature(name='match_contextual', parameters=[FunctionParameter(name='path', type_annotation=\"Annotated[Path, typer.Argument(help='Project directory to analyze')]\", default_value=None, is_required=True), FunctionParameter(name='output_format', type_annotation=\"Annotated[str, typer.Option('--format', '-f', help='Output format (terminal/json)')]\", default_value=\"'terminal'\", is_required=False), FunctionParameter(name='output_file', type_annotation=\"Annotated[Path | None, typer.Option('--output', '-o', help='Output file path')]\", default_value='None', is_required=False), FunctionParameter(name='config', type_annotation=\"Annotated[Path | None, typer.Option('--config', '-c', help='Configuration file path')]\", default_value='None', is_required=False), FunctionParameter(name='show_stats', type_annotation=\"Annotated[bool, typer.Option('--stats', help='Show performance statistics')]\", default_value='False', is_required=False), FunctionParameter(name='use_cache', type_annotation=\"Annotated[bool, typer.Option('--cache/--no-cache', help='Use parsing cache')]\", default_value='True', is_required=False), FunctionParameter(name='show_unmatched', type_annotation=\"Annotated[bool, typer.Option('--show-unmatched', help='Show unmatched functions')]\", default_value='False', is_required=False)], return_type='None', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Perform contextual matching on a project.\n\nUses both direct and contextual matching for best results.\nThis command analyzes the entire project structure, resolves imports,\nand finds documentation across files.\n\nExample:\n    codedocsync match-contextual ./myproject --stats --show-unmatched",
      "has_params": false,
      "has_returns": false,
      "has_examples": true,
      "complexity_score": 5,
      "quality_score": 3
    },
    {
      "function_name": "suggest",
      "module_path": "codedocsync\\cli\\suggest.py",
      "function_signature": "FunctionSignature(name='suggest', parameters=[FunctionParameter(name='path', type_annotation=\"Annotated[Path, typer.Argument(help='File or function to generate suggestions for')]\", default_value=\"Path('.')\", is_required=False), FunctionParameter(name='style', type_annotation=\"Annotated[str | None, typer.Option('--style', '-s', help='Docstring style (google/numpy/sphinx)')]\", default_value='None', is_required=False), FunctionParameter(name='output_format', type_annotation=\"Annotated[str, typer.Option('--format', '-f', help='Output format (terminal/json)')]\", default_value=\"'terminal'\", is_required=False), FunctionParameter(name='apply', type_annotation=\"Annotated[bool, typer.Option('--apply', '-a', help='Apply suggestions directly to files')]\", default_value='False', is_required=False), FunctionParameter(name='interactive', type_annotation=\"Annotated[bool, typer.Option('--interactive', '-i', help='Interactive suggestion review')]\", default_value='False', is_required=False), FunctionParameter(name='confidence_threshold', type_annotation=\"Annotated[float, typer.Option('--confidence', help='Minimum confidence for suggestions')]\", default_value='0.7', is_required=False), FunctionParameter(name='severity', type_annotation=\"Annotated[str | None, typer.Option('--severity', help='Filter by severity (critical/high/medium/low)')]\", default_value='None', is_required=False), FunctionParameter(name='issue_type', type_annotation=\"Annotated[str | None, typer.Option('--issue-type', help='Filter by issue type')]\", default_value='None', is_required=False), FunctionParameter(name='show_diff', type_annotation=\"Annotated[bool, typer.Option('--diff', '-d', help='Show diff view of suggestions')]\", default_value='True', is_required=False), FunctionParameter(name='backup', type_annotation=\"Annotated[bool, typer.Option('--backup/--no-backup', help='Create backup before applying')]\", default_value='True', is_required=False), FunctionParameter(name='dry_run', type_annotation=\"Annotated[bool, typer.Option('--dry-run', help='Show what would be changed without applying')]\", default_value='False', is_required=False), FunctionParameter(name='verbose', type_annotation=\"Annotated[bool, typer.Option('--verbose', '-v', help='Verbose output')]\", default_value='False', is_required=False)], return_type='None', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Generate fix suggestions for documentation issues.\n\nThis command analyzes code for documentation inconsistencies and generates\nactionable, copy-paste ready suggestions to fix them.\n\nExamples:\n    codedocsync suggest ./src/utils.py --style google\n    codedocsync suggest ./project --severity critical --format json\n    codedocsync suggest ./main.py::process_data --interactive\n    codedocsync suggest . --apply --dry-run",
      "has_params": false,
      "has_returns": false,
      "has_examples": true,
      "complexity_score": 5,
      "quality_score": 3
    },
    {
      "function_name": "set",
      "module_path": "codedocsync\\analyzer\\llm_cache.py",
      "function_signature": "FunctionSignature(name='set', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='cache_key', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='response', type_annotation='LLMAnalysisResponse', default_value=None, is_required=True), FunctionParameter(name='ttl_days', type_annotation='int', default_value='7', is_required=False), FunctionParameter(name='function_complexity', type_annotation='int', default_value='0', is_required=False), FunctionParameter(name='file_path', type_annotation='str', default_value=\"''\", is_required=False), FunctionParameter(name='analysis_types', type_annotation='list[str] | None', default_value='None', is_required=False)], return_type='None', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Cache response with TTL and metadata.\n\nArgs:\n    cache_key: Unique cache key\n    response: LLM analysis response to cache\n    ttl_days: Time to live in days\n    function_complexity: Complexity score for prioritization\n    file_path: Source file path for invalidation\n    analysis_types: Types of analysis performed",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 3
    },
    {
      "function_name": "record_request",
      "module_path": "codedocsync\\analyzer\\llm_performance.py",
      "function_signature": "FunctionSignature(name='record_request', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='analysis_type', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='response_time_ms', type_annotation='float', default_value=None, is_required=True), FunctionParameter(name='tokens_used', type_annotation='int', default_value=None, is_required=True), FunctionParameter(name='cache_hit', type_annotation='bool', default_value=None, is_required=True), FunctionParameter(name='model', type_annotation='str', default_value=\"'gpt-4o-mini'\", is_required=False), FunctionParameter(name='error', type_annotation='str | None', default_value='None', is_required=False), FunctionParameter(name='queue_depth', type_annotation='int', default_value='0', is_required=False)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Record performance metrics for a single request.\n\nArgs:\n    analysis_type: Type of analysis performed\n    response_time_ms: Total response time in milliseconds\n    tokens_used: Number of tokens consumed\n    cache_hit: Whether the request was served from cache\n    model: LLM model used\n    error: Error type if request failed\n    queue_depth: Current rate limiter queue depth",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 4,
      "quality_score": 3
    },
    {
      "function_name": "clear_cache",
      "module_path": "codedocsync\\cli\\cache.py",
      "function_signature": "FunctionSignature(name='clear_cache', parameters=[FunctionParameter(name='llm_only', type_annotation=\"Annotated[bool, typer.Option('--llm-only', help='Clear only LLM analysis cache')]\", default_value='False', is_required=False), FunctionParameter(name='older_than_days', type_annotation=\"Annotated[int, typer.Option('--older-than-days', help='Clear entries older than N days')]\", default_value='7', is_required=False), FunctionParameter(name='confirm', type_annotation=\"Annotated[bool, typer.Option('--yes', '-y', help='Skip confirmation prompt')]\", default_value='False', is_required=False)], return_type='None', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Clear analysis cache.\n\nThis command clears cached analysis results to free up disk space\nor force fresh analysis.\n\nExamples:\n    codedocsync clear-cache --llm-only\n    codedocsync clear-cache --older-than-days 30 --yes",
      "has_params": false,
      "has_returns": false,
      "has_examples": true,
      "complexity_score": 4,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='rate', type_annotation='float', default_value=None, is_required=True), FunctionParameter(name='burst_size', type_annotation='int', default_value=None, is_required=True)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize token bucket.\n\nArgs:\n    rate: Tokens per second\n    burst_size: Maximum burst capacity",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\analyzer\\llm_errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='max_retries', type_annotation='int', default_value='3', is_required=False), FunctionParameter(name='base_delay', type_annotation='float', default_value='1.0', is_required=False), FunctionParameter(name='max_delay', type_annotation='float', default_value='60.0', is_required=False), FunctionParameter(name='exponential_base', type_annotation='float', default_value='2.0', is_required=False), FunctionParameter(name='jitter', type_annotation='bool', default_value='True', is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize retry parameters.\n\nArgs:\n    max_retries: Maximum number of retry attempts\n    base_delay: Base delay in seconds for first retry\n    max_delay: Maximum delay between retries\n    exponential_base: Base for exponential backoff\n    jitter: Whether to add random jitter to delays",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\analyzer\\llm_errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='failure_threshold', type_annotation='int', default_value='5', is_required=False), FunctionParameter(name='recovery_timeout', type_annotation='int', default_value='60', is_required=False), FunctionParameter(name='expected_exception', type_annotation='type[Exception]', default_value='LLMError', is_required=False), FunctionParameter(name='half_open_max_calls', type_annotation='int', default_value='1', is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize circuit breaker.\n\nArgs:\n    failure_threshold: Number of failures before opening circuit\n    recovery_timeout: Seconds to wait before trying half-open\n    expected_exception: Exception type to consider as failure\n    half_open_max_calls: Max calls allowed in half-open state",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\analyzer\\rule_engine.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='enabled_rules', type_annotation='list[str] | None', default_value='None', is_required=False), FunctionParameter(name='performance_mode', type_annotation='bool', default_value='False', is_required=False), FunctionParameter(name='severity_overrides', type_annotation='dict[str, str] | None', default_value='None', is_required=False), FunctionParameter(name='confidence_threshold', type_annotation='float', default_value='0.9', is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize the rule engine.\n\nArgs:\n    enabled_rules: List of rule names to run (None = all rules)\n    performance_mode: Skip expensive rules for better performance\n    severity_overrides: Custom severity mappings for issue types\n    confidence_threshold: Minimum confidence to skip LLM analysis",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "suggest_interactive",
      "module_path": "codedocsync\\cli\\suggest.py",
      "function_signature": "FunctionSignature(name='suggest_interactive', parameters=[FunctionParameter(name='path', type_annotation=\"Annotated[Path, typer.Argument(help='File or directory to analyze')]\", default_value=\"Path('.')\", is_required=False)], return_type='None', is_async=False, is_method=False, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Launch interactive suggestion browser.\n\nThis provides a TUI (Text User Interface) for browsing and applying\ndocumentation fix suggestions interactively.\n\nExamples:\n    codedocsync suggest-interactive ./src\n    codedocsync suggest-interactive ./main.py",
      "has_params": false,
      "has_returns": false,
      "has_examples": true,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='message', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='fallback_style', type_annotation='str', default_value=\"'google'\", is_required=False), FunctionParameter(name='attempted_text', type_annotation='str | None', default_value='None', is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize style detection error.\n\nArgs:\n    message: Error message\n    fallback_style: Style to use as fallback\n    attempted_text: Text that failed detection\n    **kwargs: Additional arguments for base class",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='message', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='partial_result', type_annotation='str | None', default_value='None', is_required=False), FunctionParameter(name='suggestion_type', type_annotation='SuggestionType | None', default_value='None', is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize suggestion generation error.\n\nArgs:\n    message: Error message\n    partial_result: Partial suggestion if available\n    suggestion_type: Type of suggestion that failed\n    **kwargs: Additional arguments for base class",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='message', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='template_name', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='section', type_annotation='str | None', default_value='None', is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize template render error.\n\nArgs:\n    message: Error message\n    template_name: Name of template that failed\n    section: Section that failed to render\n    **kwargs: Additional arguments for base class",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='message', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='validation_type', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='invalid_content', type_annotation='str | None', default_value='None', is_required=False), FunctionParameter(name='**kwargs', type_annotation='Any', default_value=None, is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize validation error.\n\nArgs:\n    message: Error message\n    validation_type: Type of validation that failed\n    invalid_content: Content that failed validation\n    **kwargs: Additional arguments for base class",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 3,
      "quality_score": 3
    },
    {
      "function_name": "wait_for_tokens",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='wait_for_tokens', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='tokens', type_annotation='int', default_value='1', is_required=False)], return_type='None', is_async=True, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Wait until tokens are available.\n\nArgs:\n    tokens: Number of tokens needed",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\analyzer\\llm_analyzer.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='config', type_annotation='LLMConfig | None', default_value='None', is_required=False)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize with configuration and OpenAI client.\n\nArgs:\n    config: LLM configuration (creates default if None)\n\nRaises:\n    ImportError: If openai package is not available\n    ValueError: If configuration is invalid or API key missing",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\analyzer\\llm_cache.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='db_path', type_annotation='str', default_value=\"'.codedocsync_cache/llm.db'\", is_required=False)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize with SQLite backend.\n\nArgs:\n    db_path: Path to SQLite database file",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "estimate_tokens",
      "module_path": "codedocsync\\analyzer\\llm_models.py",
      "function_signature": "FunctionSignature(name='estimate_tokens', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True)], return_type='int', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Estimate token count for this request.\n\nUses rough approximation of ~4 characters per token.\nThis is critical for avoiding context overflow.\n\nReturns:\n    Estimated number of tokens for the complete request",
      "has_params": false,
      "has_returns": true,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\analyzer\\llm_output_parser.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='strict_validation', type_annotation='bool', default_value='True', is_required=False)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize parser.\n\nArgs:\n    strict_validation: If True, reject responses with any validation errors.\n                      If False, attempt to recover what we can.",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\analyzer\\llm_performance.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='window_size', type_annotation='int', default_value='1000', is_required=False), FunctionParameter(name='alert_thresholds', type_annotation='dict[str, float] | None', default_value='None', is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize performance monitor.\n\nArgs:\n    window_size: Number of recent requests to keep for metrics calculation\n    alert_thresholds: Custom alert thresholds for different metrics",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\parser\\docstring_parser.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='cache_size', type_annotation='int', default_value='500', is_required=False)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize parser with caching configuration.\n\nArgs:\n    cache_size: Maximum number of parsed docstrings to cache",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='message', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='context', type_annotation='SuggestionContext | None', default_value='None', is_required=False), FunctionParameter(name='original_error', type_annotation='Exception | None', default_value='None', is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize suggestion error.\n\nArgs:\n    message: Error message\n    context: Context when error occurred\n    original_error: Original exception that caused this error",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='max_retries', type_annotation='int', default_value='3', is_required=False), FunctionParameter(name='retry_delay', type_annotation='float', default_value='0.1', is_required=False), FunctionParameter(name='fallback_styles', type_annotation='list[str] | None', default_value='None', is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize error recovery strategy.\n\nArgs:\n    max_retries: Maximum number of retry attempts\n    retry_delay: Delay between retries in seconds\n    fallback_styles: List of fallback styles to try",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='recovery_strategy', type_annotation='ErrorRecoveryStrategy | None', default_value='None', is_required=False)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize error handler.\n\nArgs:\n    recovery_strategy: Strategy for error recovery",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='max_history', type_annotation='int', default_value='1000', is_required=False), FunctionParameter(name='enable_detailed_logging', type_annotation='bool', default_value='False', is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize performance monitor.\n\nArgs:\n    max_history: Maximum metrics to keep per operation\n    enable_detailed_logging: Enable detailed performance logging",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "reset",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='reset', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='operation', type_annotation='str | None', default_value='None', is_required=False)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Reset performance metrics.\n\nArgs:\n    operation: Specific operation to reset, or None for all",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\suggestions\\performance.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='monitor', type_annotation='SuggestionPerformanceMonitor', default_value=None, is_required=True)], return_type='None', is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize optimizer.\n\nArgs:\n    monitor: Performance monitor to analyze",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    },
    {
      "function_name": "__init__",
      "module_path": "codedocsync\\utils\\errors.py",
      "function_signature": "FunctionSignature(name='__init__', parameters=[FunctionParameter(name='self', type_annotation=None, default_value=None, is_required=True), FunctionParameter(name='message', type_annotation='str', default_value=None, is_required=True), FunctionParameter(name='recovery_hint', type_annotation='str | None', default_value='None', is_required=False)], return_type=None, is_async=False, is_method=True, decorators=[])",
      "docstring_format": "google",
      "docstring_content": "Initialize a parsing error.\n\nArgs:\n    message: The error message describing what went wrong\n    recovery_hint: Optional hint on how to recover from this error",
      "has_params": true,
      "has_returns": false,
      "has_examples": false,
      "complexity_score": 2,
      "quality_score": 3
    }
  ],
  "statistics": {
    "total_collected": 143,
    "corpus_size": 143,
    "quality_distribution": {
      "5": 18,
      "4": 95,
      "3": 30
    },
    "format_distribution": {
      "google": 141,
      "numpy": 1,
      "sphinx": 1
    }
  }
}
