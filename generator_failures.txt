============================= test session starts =============================
platform win32 -- Python 3.13.5, pytest-8.4.1, pluggy-1.6.0 -- C:\Users\issak\CodeDocSync\.venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\issak\CodeDocSync
configfile: pyproject.toml
plugins: anyio-4.9.0, asyncio-1.1.0, mock-3.14.1
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 119 items

tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_control_flow_loops PASSED [  0%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_data_operations FAILED [  1%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_side_effects PASSED [  2%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_error_handling FAILED [  3%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_performance_characteristics FAILED [  4%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_recursive_function PASSED [  5%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_function_purpose_by_name PASSED [  5%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_looks_like_validation PASSED [  6%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_syntax_error_handling PASSED [  7%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_improve_vague_description FAILED [  8%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_improve_outdated_description FAILED [  9%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_add_behavior_description FAILED [ 10%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_add_side_effects_documentation FAILED [ 10%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_generate_enhanced_description PASSED [ 11%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_generate_enhanced_description_with_side_effects_focus PASSED [ 12%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_generate_basic_purpose PASSED [ 13%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_no_source_code_fallback FAILED [ 14%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_no_patterns_detected FAILED [ 15%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_unknown_issue_type FAILED [ 15%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorGeneratorIntegration::test_complete_workflow_data_processing FAILED [ 16%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorGeneratorIntegration::test_complete_workflow_file_operations FAILED [ 17%]
tests/suggestions/generators/test_behavior_generator.py::TestBehaviorGeneratorIntegration::test_performance_pattern_detection FAILED [ 18%]
tests/suggestions/generators/test_edge_case_handlers.py::TestSpecialConstructAnalyzer::test_analyze_property_getter FAILED [ 19%]
tests/suggestions/generators/test_edge_case_handlers.py::TestSpecialConstructAnalyzer::test_analyze_classmethod FAILED [ 20%]
tests/suggestions/generators/test_edge_case_handlers.py::TestSpecialConstructAnalyzer::test_analyze_magic_method FAILED [ 21%]
tests/suggestions/generators/test_edge_case_handlers.py::TestSpecialConstructAnalyzer::test_analyze_async_function FAILED [ 21%]
tests/suggestions/generators/test_edge_case_handlers.py::TestPropertyMethodHandler::test_generate_property_getter_docstring FAILED [ 22%]
tests/suggestions/generators/test_edge_case_handlers.py::TestPropertyMethodHandler::test_property_setter_detection FAILED [ 23%]
tests/suggestions/generators/test_edge_case_handlers.py::TestPropertyMethodHandler::test_property_deleter_detection FAILED [ 24%]
tests/suggestions/generators/test_edge_case_handlers.py::TestClassMethodHandler::test_generate_classmethod_docstring FAILED [ 25%]
tests/suggestions/generators/test_edge_case_handlers.py::TestClassMethodHandler::test_staticmethod_handling FAILED [ 26%]
tests/suggestions/generators/test_edge_case_handlers.py::TestEdgeCaseSuggestionGenerator::test_generate_delegates_to_handlers PASSED [ 26%]
tests/suggestions/generators/test_edge_case_handlers.py::TestEdgeCaseSuggestionGenerator::test_generate_no_special_constructs FAILED [ 27%]
tests/suggestions/generators/test_edge_case_handlers.py::TestEdgeCaseSuggestionGenerator::test_async_function_suggestion FAILED [ 28%]
tests/suggestions/generators/test_edge_case_handlers.py::TestEdgeCaseSuggestionGenerator::test_magic_method_suggestion FAILED [ 29%]
tests/suggestions/generators/test_example_generator.py::TestParameterValueGenerator::test_generate_value_by_name FAILED [ 30%]
tests/suggestions/generators/test_example_generator.py::TestParameterValueGenerator::test_generate_value_by_type PASSED [ 31%]
tests/suggestions/generators/test_example_generator.py::TestParameterValueGenerator::test_generate_value_optional_with_default FAILED [ 31%]
tests/suggestions/generators/test_example_generator.py::TestParameterValueGenerator::test_normalize_type PASSED [ 32%]
tests/suggestions/generators/test_example_generator.py::TestParameterValueGenerator::test_fallback_value PASSED [ 33%]
tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_function_decorators PASSED [ 34%]
tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_async_function FAILED [ 35%]
tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_generator_function FAILED [ 36%]
tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_side_effects FAILED [ 36%]
tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_domain_detection FAILED [ 37%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_basic_example PASSED [ 38%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_edge_case_example PASSED [ 39%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_advanced_example PASSED [ 40%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_async_example FAILED [ 41%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_property_example FAILED [ 42%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_edge_case_values FAILED [ 42%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_advanced_values PASSED [ 43%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_expected_output FAILED [ 44%]
tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_multiple_examples FAILED [ 45%]
tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_add_missing_examples FAILED [ 46%]
tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_fix_invalid_example FAILED [ 47%]
tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_update_outdated_example FAILED [ 47%]
tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_complete_example FAILED [ 48%]
tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_format_example_code PASSED [ 49%]
tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_no_examples_generated_fallback FAILED [ 50%]
tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_unknown_issue_type FAILED [ 51%]
tests/suggestions/generators/test_example_generator.py::TestExampleGeneratorIntegration::test_complete_workflow_mathematical_function FAILED [ 52%]
tests/suggestions/generators/test_example_generator.py::TestExampleGeneratorIntegration::test_complete_workflow_file_processing_function FAILED [ 52%]
tests/suggestions/generators/test_example_generator.py::TestExampleGeneratorIntegration::test_async_function_example_generation FAILED [ 53%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_fix_parameter_name_mismatch FAILED [ 54%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_add_missing_parameter PASSED [ 55%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_fix_parameter_type_mismatch PASSED [ 56%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_fix_parameter_order FAILED [ 57%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_add_kwargs_documentation FAILED [ 57%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_filter_special_parameters FAILED [ 58%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_find_parameter_mismatches PASSED [ 59%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_types_differ PASSED [ 60%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_normalize_type FAILED [ 61%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_generate_parameter_description PASSED [ 62%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_detect_style_from_docstring FAILED [ 63%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_fallback_suggestion FAILED [ 63%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_generic_parameter_fix FAILED [ 64%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterGeneratorEdgeCases::test_empty_function_parameters FAILED [ 65%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterGeneratorEdgeCases::test_empty_documented_parameters PASSED [ 66%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterGeneratorEdgeCases::test_malformed_function_object PASSED [ 67%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterGeneratorEdgeCases::test_malformed_docstring_object PASSED [ 68%]
tests/suggestions/generators/test_parameter_generator.py::TestParameterGeneratorEdgeCases::test_classmethod_detection FAILED [ 68%]
tests/suggestions/generators/test_raises_generator.py::TestExceptionAnalyzer::test_analyze_direct_raise PASSED [ 69%]
tests/suggestions/generators/test_raises_generator.py::TestExceptionAnalyzer::test_analyze_multiple_exceptions PASSED [ 70%]
tests/suggestions/generators/test_raises_generator.py::TestExceptionAnalyzer::test_analyze_function_calls PASSED [ 71%]
tests/suggestions/generators/test_raises_generator.py::TestExceptionAnalyzer::test_analyze_subscript_operations PASSED [ 72%]
tests/suggestions/generators/test_raises_generator.py::TestExceptionAnalyzer::test_analyze_bare_raise PASSED [ 73%]
tests/suggestions/generators/test_raises_generator.py::TestExceptionAnalyzer::test_deduplicate_exceptions PASSED [ 73%]
tests/suggestions/generators/test_raises_generator.py::TestExceptionAnalyzer::test_syntax_error_handling PASSED [ 74%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_add_missing_raises_documentation FAILED [ 75%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_fix_raises_type_mismatch FAILED [ 76%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_improve_raises_description FAILED [ 77%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_is_vague_description FAILED [ 78%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_generate_improved_exception_description PASSED [ 78%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_no_source_code_fallback FAILED [ 79%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_no_significant_exceptions FAILED [ 80%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_unknown_issue_type FAILED [ 81%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesGeneratorIntegration::test_complete_workflow_file_operations FAILED [ 82%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesGeneratorIntegration::test_complete_workflow_mismatch_correction FAILED [ 83%]
tests/suggestions/generators/test_raises_generator.py::TestRaisesGeneratorIntegration::test_edge_case_no_exceptions_detected FAILED [ 84%]
tests/suggestions/generators/test_return_generator.py::TestReturnStatementAnalyzer::test_analyze_simple_return PASSED [ 84%]
tests/suggestions/generators/test_return_generator.py::TestReturnStatementAnalyzer::test_analyze_multiple_returns PASSED [ 85%]
tests/suggestions/generators/test_return_generator.py::TestReturnStatementAnalyzer::test_analyze_generator_function FAILED [ 86%]
tests/suggestions/generators/test_return_generator.py::TestReturnStatementAnalyzer::test_analyze_async_function PASSED [ 87%]
tests/suggestions/generators/test_return_generator.py::TestReturnStatementAnalyzer::test_analyze_no_return PASSED [ 88%]
tests/suggestions/generators/test_return_generator.py::TestReturnStatementAnalyzer::test_analyze_syntax_error PASSED [ 89%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_fix_return_type_mismatch FAILED [ 89%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_add_missing_return_documentation FAILED [ 90%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_improve_return_description FAILED [ 91%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_fix_generator_return FAILED [ 92%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_determine_best_return_type_single FAILED [ 93%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_determine_best_return_type_multiple FAILED [ 94%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_determine_best_return_type_generator PASSED [ 94%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_generate_return_description_basic_types PASSED [ 95%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_generate_return_description_special_cases PASSED [ 96%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_no_source_code_fallback FAILED [ 97%]
tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_unknown_issue_type FAILED [ 98%]
tests/suggestions/generators/test_return_generator.py::TestReturnGeneratorIntegration::test_complete_workflow_missing_returns FAILED [ 99%]
tests/suggestions/generators/test_return_generator.py::TestReturnGeneratorIntegration::test_complete_workflow_generator_function FAILED [100%]

================================== FAILURES ===================================
______________ TestBehaviorAnalyzer.test_analyze_data_operations ______________

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorAnalyzer object at 0x00000217B8AB8CD0>

        def test_analyze_data_operations(self) -> None:
            """Test analyzing data manipulation patterns."""
            source_code = """
    def test_func(data: Any) -> None:
        processed = [x * 2 for x in data]
        result = {}
        for item in processed:
            result[str(item)] = item
        return result
    """
            analyzer = BehaviorAnalyzer()
            patterns = analyzer.analyze_behavior(source_code, "test_func")

            pattern_types = [p.pattern_type for p in patterns]
            assert "data_transformation" in pattern_types
>           assert "data_creation" in pattern_types
E           AssertionError: assert 'data_creation' in ['iteration', 'early_exit', 'data_transformation']

tests\suggestions\generators\test_behavior_generator.py:63: AssertionError
______________ TestBehaviorAnalyzer.test_analyze_error_handling _______________

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorAnalyzer object at 0x00000217B8AB0FC0>

        def test_analyze_error_handling(self) -> None:
            """Test analyzing error handling patterns."""
            source_code = """
    def test_func(value: Any) -> None:
        assert isinstance(value, str), "Value must be string"

        if not value:
            raise ValueError("Value cannot be empty")

        try:
            result = risky_operation(value)
        except Exception as e:
            log_error(e)
            return None

        return result
    """
            analyzer = BehaviorAnalyzer()
            patterns = analyzer.analyze_behavior(source_code, "test_func")

            pattern_types = [p.pattern_type for p in patterns]
            assert "error_handling" in pattern_types
>           assert "input_validation" in pattern_types
E           AssertionError: assert 'input_validation' in ['conditional', 'early_exit', 'error_handling', 'assertion_checks']

tests\suggestions\generators\test_behavior_generator.py:106: AssertionError
________ TestBehaviorAnalyzer.test_analyze_performance_characteristics ________

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorAnalyzer object at 0x00000217B8A62F90>

        def test_analyze_performance_characteristics(self) -> None:
            """Test analyzing performance-related patterns."""
            source_code = """
    def test_func(matrix: Any) -> None:
        result = []
        for i in range(len(matrix)):
            row = []
            for j in range(len(matrix[i])):
                row.append(matrix[i][j] * 2)
            result.append(row)
        return result
    """
            analyzer = BehaviorAnalyzer()
            patterns = analyzer.analyze_behavior(source_code, "test_func")

            pattern_types = [p.pattern_type for p in patterns]
>           assert "nested_iteration" in pattern_types
E           AssertionError: assert 'nested_iteration' in ['iteration', 'early_exit', 'data_modification']

tests\suggestions\generators\test_behavior_generator.py:125: AssertionError
_______ TestBehaviorSuggestionGenerator.test_improve_vague_description ________

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorSuggestionGenerator object at 0x00000217B8AB8B90>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8AC7770>
mock_function = <Mock id='2300905814208'>
mock_docstring = <Mock id='2300905814880'>
mock_issue = InconsistencyIssue(issue_type='description_outdated', severity='medium', description='Description is too vague', suggestion='Improve description', line_number=10, confidence=1.0, details={})

    def test_improve_vague_description(
        self,
        generator: Any,
        mock_function: Any,
        mock_docstring: Any,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test improving vague description."""
        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._improve_vague_description(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_behavior_generator.py:276:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\behavior_generator.py:475: in _improve_vague_description
    return self._enhance_description(context, "vague description")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\behavior_generator.py:530: in _enhance_description
    updated_docstring = self._update_description_in_docstring(
codedocsync\suggestions\generators\behavior_generator.py:661: in _update_description_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8AC7770>
docstring = <Mock id='2300905814880'>

    def _detect_style(self, docstring: Any | None) -> str:
        """Detect docstring style from parsed docstring."""
        if docstring is not None and hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\behavior_generator.py:695: AttributeError
______ TestBehaviorSuggestionGenerator.test_improve_outdated_description ______

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorSuggestionGenerator object at 0x00000217B8AB8E10>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8B951D0>
mock_function = <Mock id='2300907143920'>
mock_docstring = <Mock id='2300907144592'>
mock_issue = InconsistencyIssue(issue_type='description_outdated', severity='medium', description='Description is too vague', suggestion='Improve description', line_number=10, confidence=1.0, details={})

    def test_improve_outdated_description(
        self,
        generator: Any,
        mock_function: Any,
        mock_docstring: Any,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test improving outdated description."""
        mock_issue.issue_type = "description_outdated"

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._improve_outdated_description(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_behavior_generator.py:300:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\behavior_generator.py:471: in _improve_outdated_description
    return self._enhance_description(context, "outdated description")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\behavior_generator.py:530: in _enhance_description
    updated_docstring = self._update_description_in_docstring(
codedocsync\suggestions\generators\behavior_generator.py:661: in _update_description_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8B951D0>
docstring = <Mock id='2300907144592'>

    def _detect_style(self, docstring: Any | None) -> str:
        """Detect docstring style from parsed docstring."""
        if docstring is not None and hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\behavior_generator.py:695: AttributeError
________ TestBehaviorSuggestionGenerator.test_add_behavior_description ________

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorSuggestionGenerator object at 0x00000217B8AB0E90>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8B95950>
mock_function = <Mock id='2300907145600'>
mock_docstring = <Mock id='2300907146272'>
mock_issue = InconsistencyIssue(issue_type='missing_behavior_description', severity='medium', description='Description is too vague', suggestion='Improve description', line_number=10, confidence=1.0, details={})

    def test_add_behavior_description(
        self,
        generator: Any,
        mock_function: Any,
        mock_docstring: Any,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test adding missing behavior description."""
        mock_issue.issue_type = "missing_behavior_description"

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._add_behavior_description(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_behavior_generator.py:319:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\behavior_generator.py:479: in _add_behavior_description
    return self._enhance_description(context, "missing behavior description")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\behavior_generator.py:530: in _enhance_description
    updated_docstring = self._update_description_in_docstring(
codedocsync\suggestions\generators\behavior_generator.py:661: in _update_description_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8B95950>
docstring = <Mock id='2300907146272'>

    def _detect_style(self, docstring: Any | None) -> str:
        """Detect docstring style from parsed docstring."""
        if docstring is not None and hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\behavior_generator.py:695: AttributeError
_____ TestBehaviorSuggestionGenerator.test_add_side_effects_documentation _____

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorSuggestionGenerator object at 0x00000217B8AB10F0>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8CB16E0>
mock_function = <Mock id='2300907147280'>
mock_docstring = <Mock id='2300907147952'>
mock_issue = InconsistencyIssue(issue_type='side_effects_undocumented', severity='medium', description='Description is too vague', suggestion='Improve description', line_number=10, confidence=1.0, details={})

        def test_add_side_effects_documentation(
            self,
            generator: Any,
            mock_function: Any,
            mock_docstring: Any,
            mock_issue: InconsistencyIssue,
        ) -> None:
            """Test adding side effects documentation."""
            # Function with side effects
            mock_function.source_code = """
    def process_data(items, log_file):
        import logging
        logging.basicConfig(filename=log_file)

        with open("output.txt", "w") as f:
            for item in items:
                processed = item.transform()
                f.write(str(processed))
                logging.info(f"Processed {item}")

        print("Processing complete")
    """
            mock_issue.issue_type = "side_effects_undocumented"

            context = SuggestionContext(
                function=mock_function, docstring=mock_docstring, issue=mock_issue
            )

>           suggestion = generator._add_side_effects_documentation(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_behavior_generator.py:352:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\behavior_generator.py:483: in _add_side_effects_documentation
    return self._enhance_description(
codedocsync\suggestions\generators\behavior_generator.py:530: in _enhance_description
    updated_docstring = self._update_description_in_docstring(
codedocsync\suggestions\generators\behavior_generator.py:661: in _update_description_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8CB16E0>
docstring = <Mock id='2300907147952'>

    def _detect_style(self, docstring: Any | None) -> str:
        """Detect docstring style from parsed docstring."""
        if docstring is not None and hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\behavior_generator.py:695: AttributeError
________ TestBehaviorSuggestionGenerator.test_no_source_code_fallback _________

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorSuggestionGenerator object at 0x00000217B8AD4650>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8AAB350>
mock_function = <Mock id='2300905815216'>
mock_docstring = <Mock id='2300905814208'>
mock_issue = InconsistencyIssue(issue_type='description_outdated', severity='medium', description='Description is too vague', suggestion='Improve description', line_number=10, confidence=1.0, details={})

    def test_no_source_code_fallback(
        self,
        generator: Any,
        mock_function: Any,
        mock_docstring: Any,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test fallback when source code is not available."""
        mock_function.source_code = ""

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._improve_vague_description(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_behavior_generator.py:435:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\behavior_generator.py:475: in _improve_vague_description
    return self._enhance_description(context, "vague description")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\behavior_generator.py:507: in _enhance_description
    return self._create_fallback_suggestion(
codedocsync\suggestions\generators\behavior_generator.py:743: in _create_fallback_suggestion
    return self._create_suggestion(
codedocsync\suggestions\generators\behavior_generator.py:735: in _create_suggestion
    style=self._detect_style(context.docstring),
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8AAB350>
docstring = <Mock id='2300905814208'>

    def _detect_style(self, docstring: Any | None) -> str:
        """Detect docstring style from parsed docstring."""
        if docstring is not None and hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\behavior_generator.py:695: AttributeError
__________ TestBehaviorSuggestionGenerator.test_no_patterns_detected __________

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorSuggestionGenerator object at 0x00000217B8AD4850>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8AD6A50>
mock_function = <Mock id='2300905811856'>
mock_docstring = <Mock id='2300907145600'>
mock_issue = InconsistencyIssue(issue_type='description_outdated', severity='medium', description='Description is too vague', suggestion='Improve description', line_number=10, confidence=1.0, details={})

        def test_no_patterns_detected(
            self,
            generator: Any,
            mock_function: Any,
            mock_docstring: Any,
            mock_issue: InconsistencyIssue,
        ) -> None:
            """Test handling when no behavioral patterns are detected."""
            # Very simple function that might not trigger pattern detection
            mock_function.source_code = """
    def simple_func():
        return 42
    """

            context = SuggestionContext(
                function=mock_function, docstring=mock_docstring, issue=mock_issue
            )

>           suggestion = generator._improve_vague_description(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_behavior_generator.py:458:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\behavior_generator.py:475: in _improve_vague_description
    return self._enhance_description(context, "vague description")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\behavior_generator.py:530: in _enhance_description
    updated_docstring = self._update_description_in_docstring(
codedocsync\suggestions\generators\behavior_generator.py:661: in _update_description_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8AD6A50>
docstring = <Mock id='2300907145600'>

    def _detect_style(self, docstring: Any | None) -> str:
        """Detect docstring style from parsed docstring."""
        if docstring is not None and hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\behavior_generator.py:695: AttributeError
___________ TestBehaviorSuggestionGenerator.test_unknown_issue_type ___________

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorSuggestionGenerator object at 0x00000217B8A0F5C0>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8AD7650>
mock_function = <Mock id='2300907145936'>
mock_docstring = <Mock id='2300907143920'>

    def test_unknown_issue_type(
        self,
        generator: Any,
        mock_function: MockerFixture,
        mock_docstring: MockerFixture,
    ) -> None:
        """Test handling unknown issue types."""
>       unknown_issue = InconsistencyIssue(
            issue_type="description_outdated",
            severity="medium",
            description="Unknown issue",
            suggestion="",
            line_number=10,
        )

tests\suggestions\generators\test_behavior_generator.py:470:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='description_outdated', severity='medium', description='Unknown issue', suggestion='', line_number=10, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
            raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )

        # Validate severity
        valid_severities = ["critical", "high", "medium", "low"]
        if self.severity not in valid_severities:
            raise ValueError(
                f"severity must be one of {valid_severities}, got '{self.severity}'"
            )

        # Validate confidence
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(
                f"confidence must be between 0.0 and 1.0, got {self.confidence}"
            )

        # Validate line_number
        if self.line_number < 1:
            raise ValueError(f"line_number must be positive, got {self.line_number}")

        # Validate required strings are not empty
        if not self.description.strip():
            raise ValueError("description cannot be empty")

        if not self.suggestion.strip():
>           raise ValueError("suggestion cannot be empty")
E           ValueError: suggestion cannot be empty

codedocsync\analyzer\models.py:90: ValueError
___ TestBehaviorGeneratorIntegration.test_complete_workflow_data_processing ___

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorGeneratorIntegration object at 0x00000217B8AB8A50>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8B29B80>

        def test_complete_workflow_data_processing(self, generator: Any) -> None:
            """Test complete workflow for data processing function."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "filter_and_transform_data"
            function.line_number = 5
            function.source_code = '''
    def filter_and_transform_data(raw_data, threshold=0.5):
        """Filter data."""
        filtered = []

        # Validate input
        if not isinstance(raw_data, list):
            raise TypeError("Expected list")

        # Process each item
        for item in raw_data:
            if hasattr(item, 'score') and item.score > threshold:
                # Transform the item
                transformed = {
                    'id': item.id,
                    'value': item.value * 2,
                    'normalized_score': item.score / 100
                }
                filtered.append(transformed)

        # Log results
        import logging
        logging.info(f"Processed {len(filtered)} items")

        return filtered
    '''

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Filter data"  # Vague
            docstring.description = None
            docstring.parameters = []
            docstring.returns = None
            docstring.raises = []
            docstring.examples = []
            docstring.raw_text = '"""Filter data."""'

            issue = InconsistencyIssue(
                issue_type="description_outdated",
                severity="medium",
                description="Description is too vague",
                suggestion="Improve description clarity",
                line_number=5,
            )

            context = SuggestionContext(function=function, docstring=docstring, issue=issue)

>           suggestion = generator.generate(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_behavior_generator.py:555:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\behavior_generator.py:459: in generate
    return self._improve_outdated_description(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\behavior_generator.py:471: in _improve_outdated_description
    return self._enhance_description(context, "outdated description")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\behavior_generator.py:530: in _enhance_description
    updated_docstring = self._update_description_in_docstring(
codedocsync\suggestions\generators\behavior_generator.py:661: in _update_description_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8B29B80>
docstring = <Mock id='2300907143584'>

    def _detect_style(self, docstring: Any | None) -> str:
        """Detect docstring style from parsed docstring."""
        if docstring is not None and hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\behavior_generator.py:695: AttributeError
___ TestBehaviorGeneratorIntegration.test_complete_workflow_file_operations ___

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorGeneratorIntegration object at 0x00000217B8AB8F50>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8B28D70>

        def test_complete_workflow_file_operations(self, generator: Any) -> None:
            """Test complete workflow for file operations with side effects."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "backup_and_process_file"
            function.line_number = 8
            function.source_code = '''
    def backup_and_process_file(filepath, backup_dir):
        """Process file."""
        import os
        import shutil
        import logging

        # Create backup
        backup_path = os.path.join(backup_dir, os.path.basename(filepath))
        shutil.copy2(filepath, backup_path)
        logging.info(f"Created backup: {backup_path}")

        # Process original file
        with open(filepath, 'r') as f:
            content = f.read()

        processed_content = content.upper()

        with open(filepath, 'w') as f:
            f.write(processed_content)

        print(f"Processed file: {filepath}")
        return backup_path
    '''

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Process file"
            docstring.description = None
            docstring.parameters = []
            docstring.returns = None
            docstring.raises = []
            docstring.examples = []
            docstring.raw_text = '"""Process file."""'

>           issue = InconsistencyIssue(
                issue_type="side_effects_undocumented",
                severity="high",
                description="Side effects not documented",
                suggestion="Document side effects",
                line_number=8,
            )

tests\suggestions\generators\test_behavior_generator.py:614:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='side_effects_undocumented', severity='high', description='Side effects not documented', suggestion='Document side effects', line_number=8, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
>           raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )
E           ValueError: issue_type must be one of ['parameter_name_mismatch', 'parameter_missing', 'parameter_type_mismatch', 'return_type_mismatch', 'missing_raises', 'parameter_order_different', 'description_outdated', 'example_invalid', 'missing_params', 'missing_returns', 'undocumented_kwargs', 'type_mismatches', 'default_mismatches', 'parameter_count_mismatch'], got 'side_effects_undocumented'

codedocsync\analyzer\models.py:63: ValueError
_____ TestBehaviorGeneratorIntegration.test_performance_pattern_detection _____

self = <tests.suggestions.generators.test_behavior_generator.TestBehaviorGeneratorIntegration object at 0x00000217B8AB0B00>
generator = <codedocsync.suggestions.generators.behavior_generator.BehaviorSuggestionGenerator object at 0x00000217B8B40750>

        def test_performance_pattern_detection(self, generator: Any) -> None:
            """Test detection of performance-related patterns."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "matrix_multiply"
            function.line_number = 3
            function.source_code = '''
    def matrix_multiply(a, b):
        """Multiply matrices."""
        result = []
        for i in range(len(a)):
            row = []
            for j in range(len(b[0])):
                sum_val = 0
                for k in range(len(b)):
                    sum_val += a[i][k] * b[k][j]
                row.append(sum_val)
            result.append(row)
        return result
    '''

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Multiply matrices"
            docstring.description = None
            docstring.raw_text = '"""Multiply matrices."""'

>           issue = InconsistencyIssue(
                issue_type="description_outdated",
                severity="medium",
                description="Should mention performance characteristics",
                suggestion="",
                line_number=3,
            )

tests\suggestions\generators\test_behavior_generator.py:667:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='description_outdated', severity='medium', description='Should mention performance characteristics', suggestion='', line_number=3, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
            raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )

        # Validate severity
        valid_severities = ["critical", "high", "medium", "low"]
        if self.severity not in valid_severities:
            raise ValueError(
                f"severity must be one of {valid_severities}, got '{self.severity}'"
            )

        # Validate confidence
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(
                f"confidence must be between 0.0 and 1.0, got {self.confidence}"
            )

        # Validate line_number
        if self.line_number < 1:
            raise ValueError(f"line_number must be positive, got {self.line_number}")

        # Validate required strings are not empty
        if not self.description.strip():
            raise ValueError("description cannot be empty")

        if not self.suggestion.strip():
>           raise ValueError("suggestion cannot be empty")
E           ValueError: suggestion cannot be empty

codedocsync\analyzer\models.py:90: ValueError
__________ TestSpecialConstructAnalyzer.test_analyze_property_getter __________

self = <tests.suggestions.generators.test_edge_case_handlers.TestSpecialConstructAnalyzer object at 0x00000217B8AB9090>
analyzer = <codedocsync.suggestions.generators.edge_case_handlers.SpecialConstructAnalyzer object at 0x00000217B8C0DFD0>

    def test_analyze_property_getter(self, analyzer: Any) -> None:
        """Test analyzing property getter."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.decorators = ["property"]

>       constructs = analyzer.analyze_function(function)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:41:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:121: in analyze_function
    if self._is_generator_function(source_code):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\edge_case_handlers.py:162: in _is_generator_function
    tree = ast.parse(source_code)
           ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <Mock name='mock.source_code' id='2300907152992'>
filename = '<unknown>', mode = 'exec'

    def parse(source, filename='<unknown>', mode='exec', *,
              type_comments=False, feature_version=None, optimize=-1):
        """
        Parse the source into an AST node.
        Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
        Pass type_comments=True to get back type comments where the syntax allows.
        """
        flags = PyCF_ONLY_AST
        if optimize > 0:
            flags |= PyCF_OPTIMIZED_AST
        if type_comments:
            flags |= PyCF_TYPE_COMMENTS
        if feature_version is None:
            feature_version = -1
        elif isinstance(feature_version, tuple):
            major, minor = feature_version  # Should be a 2-tuple.
            if major != 3:
                raise ValueError(f"Unsupported major version: {major}")
            feature_version = minor
        # Else it should be an int giving the minor version for 3.x.
>       return compile(source, filename, mode, flags,
                       _feature_version=feature_version, optimize=optimize)
E       TypeError: compile() arg 1 must be a string, bytes or AST object

C:\Python313\Lib\ast.py:50: TypeError
____________ TestSpecialConstructAnalyzer.test_analyze_classmethod ____________

self = <tests.suggestions.generators.test_edge_case_handlers.TestSpecialConstructAnalyzer object at 0x00000217B8AB91D0>
analyzer = <codedocsync.suggestions.generators.edge_case_handlers.SpecialConstructAnalyzer object at 0x00000217B8B95590>

    def test_analyze_classmethod(self, analyzer: Any) -> None:
        """Test analyzing class method."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.decorators = ["classmethod"]

>       constructs = analyzer.analyze_function(function)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:55:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:121: in analyze_function
    if self._is_generator_function(source_code):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\edge_case_handlers.py:162: in _is_generator_function
    tree = ast.parse(source_code)
           ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <Mock name='mock.source_code' id='2300905811520'>
filename = '<unknown>', mode = 'exec'

    def parse(source, filename='<unknown>', mode='exec', *,
              type_comments=False, feature_version=None, optimize=-1):
        """
        Parse the source into an AST node.
        Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
        Pass type_comments=True to get back type comments where the syntax allows.
        """
        flags = PyCF_ONLY_AST
        if optimize > 0:
            flags |= PyCF_OPTIMIZED_AST
        if type_comments:
            flags |= PyCF_TYPE_COMMENTS
        if feature_version is None:
            feature_version = -1
        elif isinstance(feature_version, tuple):
            major, minor = feature_version  # Should be a 2-tuple.
            if major != 3:
                raise ValueError(f"Unsupported major version: {major}")
            feature_version = minor
        # Else it should be an int giving the minor version for 3.x.
>       return compile(source, filename, mode, flags,
                       _feature_version=feature_version, optimize=optimize)
E       TypeError: compile() arg 1 must be a string, bytes or AST object

C:\Python313\Lib\ast.py:50: TypeError
___________ TestSpecialConstructAnalyzer.test_analyze_magic_method ____________

self = <tests.suggestions.generators.test_edge_case_handlers.TestSpecialConstructAnalyzer object at 0x00000217B8AB1220>
analyzer = <codedocsync.suggestions.generators.edge_case_handlers.SpecialConstructAnalyzer object at 0x00000217B8B951D0>

    def test_analyze_magic_method(self, analyzer: Any) -> None:
        """Test analyzing magic method."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.name = "__init__"
        function.signature.decorators = []

>       constructs = analyzer.analyze_function(function)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:70:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:121: in analyze_function
    if self._is_generator_function(source_code):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\edge_case_handlers.py:162: in _is_generator_function
    tree = ast.parse(source_code)
           ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <Mock name='mock.source_code' id='2300905814880'>
filename = '<unknown>', mode = 'exec'

    def parse(source, filename='<unknown>', mode='exec', *,
              type_comments=False, feature_version=None, optimize=-1):
        """
        Parse the source into an AST node.
        Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
        Pass type_comments=True to get back type comments where the syntax allows.
        """
        flags = PyCF_ONLY_AST
        if optimize > 0:
            flags |= PyCF_OPTIMIZED_AST
        if type_comments:
            flags |= PyCF_TYPE_COMMENTS
        if feature_version is None:
            feature_version = -1
        elif isinstance(feature_version, tuple):
            major, minor = feature_version  # Should be a 2-tuple.
            if major != 3:
                raise ValueError(f"Unsupported major version: {major}")
            feature_version = minor
        # Else it should be an int giving the minor version for 3.x.
>       return compile(source, filename, mode, flags,
                       _feature_version=feature_version, optimize=optimize)
E       TypeError: compile() arg 1 must be a string, bytes or AST object

C:\Python313\Lib\ast.py:50: TypeError
__________ TestSpecialConstructAnalyzer.test_analyze_async_function ___________

self = <tests.suggestions.generators.test_edge_case_handlers.TestSpecialConstructAnalyzer object at 0x00000217B8AB15B0>
analyzer = <codedocsync.suggestions.generators.edge_case_handlers.SpecialConstructAnalyzer object at 0x00000217B8CB16E0>

    def test_analyze_async_function(self, analyzer: Any) -> None:
        """Test analyzing async function."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.is_async = True
        function.signature.decorators = []

>       constructs = analyzer.analyze_function(function)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:85:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:121: in analyze_function
    if self._is_generator_function(source_code):
       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\edge_case_handlers.py:162: in _is_generator_function
    tree = ast.parse(source_code)
           ^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

source = <Mock name='mock.source_code' id='2300907148624'>
filename = '<unknown>', mode = 'exec'

    def parse(source, filename='<unknown>', mode='exec', *,
              type_comments=False, feature_version=None, optimize=-1):
        """
        Parse the source into an AST node.
        Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
        Pass type_comments=True to get back type comments where the syntax allows.
        """
        flags = PyCF_ONLY_AST
        if optimize > 0:
            flags |= PyCF_OPTIMIZED_AST
        if type_comments:
            flags |= PyCF_TYPE_COMMENTS
        if feature_version is None:
            feature_version = -1
        elif isinstance(feature_version, tuple):
            major, minor = feature_version  # Should be a 2-tuple.
            if major != 3:
                raise ValueError(f"Unsupported major version: {major}")
            feature_version = minor
        # Else it should be an int giving the minor version for 3.x.
>       return compile(source, filename, mode, flags,
                       _feature_version=feature_version, optimize=optimize)
E       TypeError: compile() arg 1 must be a string, bytes or AST object

C:\Python313\Lib\ast.py:50: TypeError
______ TestPropertyMethodHandler.test_generate_property_getter_docstring ______

self = <tests.suggestions.generators.test_edge_case_handlers.TestPropertyMethodHandler object at 0x00000217B8AB9310>
handler = <codedocsync.suggestions.generators.edge_case_handlers.PropertyMethodHandler object at 0x00000217B8C0D400>
property_context = SuggestionContext(issue=InconsistencyIssue(issue_type='missing_params', severity='high', description='Property getter ...'google', max_line_length=88, preserve_descriptions=True, surrounding_code=None, related_functions=[], file_imports=[])

    def test_generate_property_getter_docstring(
        self, handler: Any, property_context: Any
    ) -> None:
        """Test generating docstring for property getter."""
>       suggestion = handler.handle_property_getter(property_context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:130:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:221: in handle_property_getter
    return self._create_suggestion(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.edge_case_handlers.PropertyMethodHandler object at 0x00000217B8C0D400>
context = SuggestionContext(issue=InconsistencyIssue(issue_type='missing_params', severity='high', description='Property getter ...'google', max_line_length=88, preserve_descriptions=True, surrounding_code=None, related_functions=[], file_imports=[])
suggested_text = '"""\nGet the username\n\nReturns:\n    str: Get the username\n"""'
description = 'Format as property getter documentation', confidence = 0.9
suggestion_type = <SuggestionType.FULL_DOCSTRING: 'full_docstring'>

    def _create_suggestion(
        self,
        context: SuggestionContext,
        suggested_text: str,
        description: str,
        confidence: float,
        suggestion_type: SuggestionType,
    ) -> Suggestion:
        """Create a suggestion object."""
        original_text = (
            getattr(context.docstring, "raw_text", "") if context.docstring else ""
        )

        original_lines = original_text.split("\n") if original_text else []
        suggested_lines = suggested_text.split("\n")

        diff = SuggestionDiff(
            original_lines=original_lines,
            suggested_lines=suggested_lines,
            start_line=getattr(context.function, "line_number", 1),
>           end_line=getattr(context.function, "line_number", 1) + len(original_lines),
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        )
E       TypeError: unsupported operand type(s) for +: 'Mock' and 'int'

codedocsync\suggestions\generators\edge_case_handlers.py:380: TypeError
__________ TestPropertyMethodHandler.test_property_setter_detection ___________

self = <tests.suggestions.generators.test_edge_case_handlers.TestPropertyMethodHandler object at 0x00000217B8AB9450>
handler = <codedocsync.suggestions.generators.edge_case_handlers.PropertyMethodHandler object at 0x00000217B8B95310>

    def test_property_setter_detection(self, handler: Any) -> None:
        """Test detecting property setter."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.name = "username"
        function.signature.decorators = ["username.setter"]

>       assert handler._is_property_setter(function) is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PropertyMethodHandler' object has no attribute '_is_property_setter'. Did you mean: 'handle_property_setter'?

tests\suggestions\generators\test_edge_case_handlers.py:145: AttributeError
__________ TestPropertyMethodHandler.test_property_deleter_detection __________

self = <tests.suggestions.generators.test_edge_case_handlers.TestPropertyMethodHandler object at 0x00000217B8AB16E0>
handler = <codedocsync.suggestions.generators.edge_case_handlers.PropertyMethodHandler object at 0x00000217B8B956D0>

    def test_property_deleter_detection(self, handler: Any) -> None:
        """Test detecting property deleter."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.name = "username"
        function.signature.decorators = ["username.deleter"]

>       assert handler._is_property_deleter(function) is True
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'PropertyMethodHandler' object has no attribute '_is_property_deleter'. Did you mean: 'handle_property_deleter'?

tests\suggestions\generators\test_edge_case_handlers.py:154: AttributeError
_________ TestClassMethodHandler.test_generate_classmethod_docstring __________

self = <tests.suggestions.generators.test_edge_case_handlers.TestClassMethodHandler object at 0x00000217B8AB9590>
handler = <codedocsync.suggestions.generators.edge_case_handlers.ClassMethodHandler object at 0x00000217B8AC7A10>
classmethod_context = SuggestionContext(issue=InconsistencyIssue(issue_type='missing_params', severity='high', description='Class method has...'google', max_line_length=88, preserve_descriptions=True, surrounding_code=None, related_functions=[], file_imports=[])

    def test_generate_classmethod_docstring(
        self, handler: Any, classmethod_context: Any
    ) -> None:
        """Test generating docstring for class method."""
>       suggestion = handler.handle_classmethod(classmethod_context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:203:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:425: in handle_classmethod
    suggested_docstring = template.render_complete_docstring(
codedocsync\suggestions\templates\base.py:70: in render_complete_docstring
    param_lines = self.render_parameters(parameters)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\templates\google_template.py:45: in render_parameters
    param_line = self._format_parameter_line(param)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\templates\google_template.py:115: in _format_parameter_line
    formatted_type = self._format_type_annotation(param.type_str)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.templates.google_template.GoogleStyleTemplate object at 0x00000217B8B94B90>
type_str = <Mock name='mock.type_str.strip()' id='2300907150640'>

    def _format_type_annotation(self, type_str: str | None) -> str:
        """Format type annotation for docstring style."""
        if not type_str:
            return ""

        # Normalize common type representations
        type_str = type_str.strip()

        # Handle Optional types
        if type_str.startswith("Optional[") and type_str.endswith("]"):
>           inner_type = type_str[9:-1]
                         ^^^^^^^^^^^^^^
E           TypeError: 'Mock' object is not subscriptable

codedocsync\suggestions\templates\base.py:144: TypeError
______________ TestClassMethodHandler.test_staticmethod_handling ______________

self = <tests.suggestions.generators.test_edge_case_handlers.TestClassMethodHandler object at 0x00000217B8AB96D0>
handler = <codedocsync.suggestions.generators.edge_case_handlers.ClassMethodHandler object at 0x00000217B8B95590>

    def test_staticmethod_handling(self, handler: Any) -> None:
        """Test that static methods are also handled."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.decorators = ["staticmethod"]

>       constructs = handler._analyze_constructs(function)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'ClassMethodHandler' object has no attribute '_analyze_constructs'

tests\suggestions\generators\test_edge_case_handlers.py:219: AttributeError
_____ TestEdgeCaseSuggestionGenerator.test_generate_no_special_constructs _____

self = <tests.suggestions.generators.test_edge_case_handlers.TestEdgeCaseSuggestionGenerator object at 0x00000217B8AB9950>
generator = <codedocsync.suggestions.generators.edge_case_handlers.EdgeCaseSuggestionGenerator object at 0x00000217B8B95810>
property_context = SuggestionContext(issue=InconsistencyIssue(issue_type='missing_params', severity='high', description='Property getter ...'google', max_line_length=88, preserve_descriptions=True, surrounding_code=None, related_functions=[], file_imports=[])

    def test_generate_no_special_constructs(
        self, generator: Any, property_context: Any
    ) -> None:
        """Test when no special constructs are found."""
        # Mock the analyzer to return empty list
        mock_analyzer = Mock()
        mock_analyzer.analyze_function.return_value = []
        generator.analyzer = mock_analyzer

>       result = generator.generate(property_context)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:300:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:571: in generate
    return self._handle_generic_edge_case(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\edge_case_handlers.py:725: in _handle_generic_edge_case
    return self._create_fallback_suggestion(
codedocsync\suggestions\generators\edge_case_handlers.py:779: in _create_fallback_suggestion
    return self._create_suggestion(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.edge_case_handlers.EdgeCaseSuggestionGenerator object at 0x00000217B8B95810>
context = SuggestionContext(issue=InconsistencyIssue(issue_type='missing_params', severity='high', description='Property getter ...'google', max_line_length=88, preserve_descriptions=True, surrounding_code=None, related_functions=[], file_imports=[])
suggested_text = ''
description = 'Unable to generate specific edge case fix: No specific edge case handling available'
confidence = 0.1
suggestion_type = <SuggestionType.DESCRIPTION_UPDATE: 'description'>

    def _create_suggestion(
        self,
        context: SuggestionContext,
        suggested_text: str,
        description: str,
        confidence: float,
        suggestion_type: SuggestionType,
    ) -> Suggestion:
        """Create a suggestion object."""
        original_text = (
            getattr(context.docstring, "raw_text", "") if context.docstring else ""
        )

        original_lines = original_text.split("\n") if original_text else []
        suggested_lines = suggested_text.split("\n")

        diff = SuggestionDiff(
            original_lines=original_lines,
            suggested_lines=suggested_lines,
            start_line=getattr(context.function, "line_number", 1),
>           end_line=getattr(context.function, "line_number", 1) + len(original_lines),
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        )
E       TypeError: unsupported operand type(s) for +: 'Mock' and 'int'

codedocsync\suggestions\generators\edge_case_handlers.py:756: TypeError
_______ TestEdgeCaseSuggestionGenerator.test_async_function_suggestion ________

self = <tests.suggestions.generators.test_edge_case_handlers.TestEdgeCaseSuggestionGenerator object at 0x00000217B8AB1810>
generator = <codedocsync.suggestions.generators.edge_case_handlers.EdgeCaseSuggestionGenerator object at 0x00000217B8B95A90>

    def test_async_function_suggestion(self, generator: Any) -> None:
        """Test generating suggestion for async function."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.name = "fetch_data"
        function.signature.is_async = True
        function.signature.return_annotation = "dict"
        function.signature.parameters = []

        issue = InconsistencyIssue(
            issue_type="missing_params",
            severity="high",
            description="Async function has no docstring",
            suggestion="Add a docstring",
            line_number=30,
        )

        context = SuggestionContext(
            issue=issue,
            function=function,
            project_style="google",
        )

>       suggestion = generator.generate(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:328:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:547: in generate
    constructs = self.analyzer.analyze_function(context.function)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.edge_case_handlers.SpecialConstructAnalyzer object at 0x00000217B8C3A360>
function = <Mock id='2300907146944'>

    def analyze_function(self, function: Any) -> list[SpecialConstruct]:
        """Analyze function for special constructs that need edge case handling."""
        constructs: list[SpecialConstruct] = []

        if not hasattr(function, "signature"):
            return constructs

        sig = function.signature
        decorators = getattr(sig, "decorators", []) or []

        # Check for property decorators
>       if "property" in decorators:
           ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\edge_case_handlers.py:49: TypeError
________ TestEdgeCaseSuggestionGenerator.test_magic_method_suggestion _________

self = <tests.suggestions.generators.test_edge_case_handlers.TestEdgeCaseSuggestionGenerator object at 0x00000217B8AB1940>
generator = <codedocsync.suggestions.generators.edge_case_handlers.EdgeCaseSuggestionGenerator object at 0x00000217B8CB15B0>

    def test_magic_method_suggestion(self, generator: Any) -> None:
        """Test generating suggestion for magic method."""
        function: Mock = Mock()
        function.signature = Mock()
        function.signature.name = "__str__"
        function.signature.return_annotation = "str"
        function.signature.parameters = []

        issue = InconsistencyIssue(
            issue_type="missing_params",
            severity="medium",
            description="Magic method has no docstring",
            suggestion="Add a docstring",
            line_number=40,
        )

        context = SuggestionContext(
            issue=issue,
            function=function,
            project_style="google",
        )

>       suggestion = generator.generate(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_edge_case_handlers.py:358:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\edge_case_handlers.py:547: in generate
    constructs = self.analyzer.analyze_function(context.function)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.edge_case_handlers.SpecialConstructAnalyzer object at 0x00000217B8C38050>
function = <Mock id='2300907145264'>

    def analyze_function(self, function: Any) -> list[SpecialConstruct]:
        """Analyze function for special constructs that need edge case handling."""
        constructs: list[SpecialConstruct] = []

        if not hasattr(function, "signature"):
            return constructs

        sig = function.signature
        decorators = getattr(sig, "decorators", []) or []

        # Check for property decorators
>       if "property" in decorators:
           ^^^^^^^^^^^^^^^^^^^^^^^^
E       TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\edge_case_handlers.py:49: TypeError
___________ TestParameterValueGenerator.test_generate_value_by_name ___________

self = <tests.suggestions.generators.test_example_generator.TestParameterValueGenerator object at 0x00000217B8AB9D10>
generator = <codedocsync.suggestions.generators.example_generator.ParameterValueGenerator object at 0x00000217B8AC6E40>

    def test_generate_value_by_name(self, generator: Any) -> None:
        """Test value generation based on parameter names."""
        test_cases = [
            ("name", '"John Doe"'),
            ("filename", '"example.txt"'),
            ("url", '"https://example.com"'),
            ("email", '"user@example.com"'),
            ("count", "10"),
            ("age", "25"),
            ("data", "[1, 2, 3, 4, 5]"),
        ]

        for param_name, expected_value in test_cases:
            param: Mock = Mock()
            param.name = param_name
            param.type_annotation = None
            param.is_required = True
            param.default_value = None

            result = generator.generate_value(param)
>           assert result == expected_value
E           assert '"John Doe"' == '"example.txt"'
E
E             - "example.txt"
E             + "John Doe"

tests\suggestions\generators\test_example_generator.py:58: AssertionError
____ TestParameterValueGenerator.test_generate_value_optional_with_default ____

self = <tests.suggestions.generators.test_example_generator.TestParameterValueGenerator object at 0x00000217B8AB1A70>
generator = <codedocsync.suggestions.generators.example_generator.ParameterValueGenerator object at 0x00000217B8B95A90>

    def test_generate_value_optional_with_default(self, generator: Any) -> None:
        """Test value generation for optional parameters with defaults."""
        param: Mock = Mock()
        param.name = "timeout"
        param.type_annotation = "int"
        param.is_required = False
        param.default_value = "30"

        result = generator.generate_value(param)
>       assert result == "30"
E       AssertionError: assert '42' == '30'
E
E         - 30
E         + 42

tests\suggestions\generators\test_example_generator.py:90: AssertionError
___________ TestExamplePatternAnalyzer.test_analyze_async_function ____________

self = <tests.suggestions.generators.test_example_generator.TestExamplePatternAnalyzer object at 0x00000217B8AB9F90>
analyzer = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8B951D0>

        def test_analyze_async_function(self, analyzer: Any) -> None:
            """Test analyzing async functions."""
            source_code = """
    async def fetch_data():
        return await api_call()
    """

>           analysis = analyzer.analyze_function(Mock(), source_code)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:144:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8B951D0>
function = <Mock id='2300905814880'>
source_code = '\nasync def fetch_data():\n    return await api_call()\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
_________ TestExamplePatternAnalyzer.test_analyze_generator_function __________

self = <tests.suggestions.generators.test_example_generator.TestExamplePatternAnalyzer object at 0x00000217B8AB1CD0>
analyzer = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8B95810>

        def test_analyze_generator_function(self, analyzer: Any) -> None:
            """Test analyzing generator functions."""
            source_code = """
    def number_generator():
        for i in range(10):
            yield i
    """

>           analysis = analyzer.analyze_function(Mock(), source_code)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:156:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8B95810>
function = <Mock id='2300905815552'>
source_code = '\ndef number_generator():\n    for i in range(10):\n        yield i\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
____________ TestExamplePatternAnalyzer.test_analyze_side_effects _____________

self = <tests.suggestions.generators.test_example_generator.TestExamplePatternAnalyzer object at 0x00000217B8AB1E00>
analyzer = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8CB1810>

        def test_analyze_side_effects(self, analyzer: Any) -> None:
            """Test analyzing functions with side effects."""
            source_code = """
    def process_file(filename):
        with open(filename, 'w') as f:
            f.write("data")
        print("Done")
    """

>           analysis = analyzer.analyze_function(Mock(), source_code)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:169:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8CB1810>
function = <Mock id='2300907146944'>
source_code = '\ndef process_file(filename):\n    with open(filename, \'w\') as f:\n        f.write("data")\n    print("Done")\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
__________ TestExamplePatternAnalyzer.test_analyze_domain_detection ___________

self = <tests.suggestions.generators.test_example_generator.TestExamplePatternAnalyzer object at 0x00000217B8B38950>
analyzer = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8CB16E0>

        def test_analyze_domain_detection(self, analyzer: Any) -> None:
            """Test domain detection from function calls."""
            math_source = """
    def calculate():
        return sqrt(x) + sin(y)
    """

            file_source = """
    def process():
        with open("file.txt") as f:
            return f.read()
    """

>           math_analysis = analyzer.analyze_function(Mock(), math_source)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:186:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8CB16E0>
function = <Mock id='2300907145936'>
source_code = '\ndef calculate():\n    return sqrt(x) + sin(y)\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
______________ TestExampleGenerator.test_generate_async_example _______________

self = <tests.suggestions.generators.test_example_generator.TestExampleGenerator object at 0x00000217B8AB2060>
generator = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x00000217B8CB0640>

    def test_generate_async_example(self, generator: Any) -> None:
        """Test generating example for async function."""
        async_function: Mock = Mock()
        async_function.signature = Mock()
        async_function.signature.name = "fetch_data"
        async_function.signature.parameters = []

        analysis = {
            "is_async": True,
            "return_type": "dict",
        }

>       example = generator._generate_basic_example(async_function, analysis)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:286:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x00000217B8CB0640>
function = <Mock id='2300907144592'>
analysis = {'is_async': True, 'return_type': 'dict'}

    def _generate_basic_example(
        self, function: Any, analysis: dict[str, Any]
    ) -> ExampleTemplate | None:
        """Generate a basic usage example."""
        if not hasattr(function, "signature"):
            return None

        sig = function.signature
        function_name = sig.name

        # Generate parameter values
        call_args = []
        setup_lines = []
        imports: list[str] = []

        # Handle different function types
>       if analysis["is_classmethod"]:
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'is_classmethod'

codedocsync\suggestions\generators\example_generator.py:265: KeyError
_____________ TestExampleGenerator.test_generate_property_example _____________

self = <tests.suggestions.generators.test_example_generator.TestExampleGenerator object at 0x00000217B8B395B0>
generator = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x0000021798B956E0>

    def test_generate_property_example(self, generator: Any) -> None:
        """Test generating example for property."""
        property_function: Mock = Mock()
        property_function.signature = Mock()
        property_function.signature.name = "name"
        property_function.signature.parameters = []

        analysis = {
            "is_property": True,
            "return_type": "str",
        }

>       example = generator._generate_basic_example(property_function, analysis)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:303:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x0000021798B956E0>
function = <Mock id='2300905813872'>
analysis = {'is_property': True, 'return_type': 'str'}

    def _generate_basic_example(
        self, function: Any, analysis: dict[str, Any]
    ) -> ExampleTemplate | None:
        """Generate a basic usage example."""
        if not hasattr(function, "signature"):
            return None

        sig = function.signature
        function_name = sig.name

        # Generate parameter values
        call_args = []
        setup_lines = []
        imports: list[str] = []

        # Handle different function types
>       if analysis["is_classmethod"]:
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'is_classmethod'

codedocsync\suggestions\generators\example_generator.py:265: KeyError
_____________ TestExampleGenerator.test_generate_edge_case_values _____________

self = <tests.suggestions.generators.test_example_generator.TestExampleGenerator object at 0x00000217B8AA9AE0>
generator = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x00000217B8AFDFD0>

    def test_generate_edge_case_values(self, generator: Any) -> None:
        """Test generation of edge case parameter values."""
        test_cases = [
            ("count", "0"),
            ("index", "-1"),
            ("items", "[]"),
            ("config", "{}"),
        ]

        for param_name, expected_value in test_cases:
            param: Mock = Mock()
            param.name = param_name
            param.type_annotation = None

            result = generator._generate_edge_case_value(param)
>           assert result == expected_value
E           AssertionError: assert 'None' == '{}'
E
E             - {}
E             + None

tests\suggestions\generators\test_example_generator.py:324: AssertionError
_____________ TestExampleGenerator.test_generate_expected_output ______________

self = <tests.suggestions.generators.test_example_generator.TestExampleGenerator object at 0x00000217B8AD5550>
generator = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x00000217B8C38490>

    def test_generate_expected_output(self, generator: Any) -> None:
        """Test generation of expected output."""
        test_cases = [
            ({"return_type": "str"}, '"result"'),
            ({"return_type": "int"}, "42"),
            ({"return_type": "bool"}, "True"),
            ({"return_type": "None"}, "None"),
            ({"is_generator": True}, "# Generator object"),
        ]

        for analysis, expected_output in test_cases:
>           result = generator._generate_expected_output(analysis)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:348:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x00000217B8C38490>
analysis = {'is_generator': True}

    def _generate_expected_output(self, analysis: dict[str, Any]) -> str:
        """Generate expected output description."""
>       if analysis["return_type"]:
           ^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'return_type'

codedocsync\suggestions\generators\example_generator.py:447: KeyError
____________ TestExampleGenerator.test_generate_multiple_examples _____________

self = <tests.suggestions.generators.test_example_generator.TestExampleGenerator object at 0x00000217B8AD5650>
generator = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x00000217B8AD7750>
mock_function = <Mock id='2300905815552'>

    def test_generate_multiple_examples(
        self, generator: Any, mock_function: Mock
    ) -> None:
        """Test generating multiple examples."""
>       examples = generator.generate_examples(mock_function, count=3)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:355:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\example_generator.py:226: in generate_examples
    analysis = self.pattern_analyzer.analyze_function(function, source_code)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8B74C90>
function = <Mock id='2300905815552'>, source_code = ''

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
__________ TestExampleSuggestionGenerator.test_add_missing_examples ___________

self = <tests.suggestions.generators.test_example_generator.TestExampleSuggestionGenerator object at 0x00000217B8ABA210>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x00000217B8C0CAD0>
mock_function = <Mock id='2300907143584'>
mock_docstring = <Mock id='2300907146608'>
mock_issue = InconsistencyIssue(issue_type='example_invalid', severity='low', description='Missing usage examples', suggestion='Add examples', line_number=10, confidence=1.0, details={})

    def test_add_missing_examples(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test adding missing examples."""
        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._add_missing_examples(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:445:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\example_generator.py:493: in _add_missing_examples
    return self._generate_new_examples(context, "add missing examples")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:512: in _generate_new_examples
    examples = generator.generate_examples(function, source_code, count=2)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:226: in generate_examples
    analysis = self.pattern_analyzer.analyze_function(function, source_code)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8D67380>
function = <Mock id='2300907143584'>
source_code = '\ndef calculate_area(width, height):\n    return width * height\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
___________ TestExampleSuggestionGenerator.test_fix_invalid_example ___________

self = <tests.suggestions.generators.test_example_generator.TestExampleSuggestionGenerator object at 0x00000217B8ABA350>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x00000217B8B95590>
mock_function = <Mock id='2300907148288'>
mock_docstring = <Mock id='2300907149296'>
mock_issue = InconsistencyIssue(issue_type='example_invalid', severity='low', description='Missing usage examples', suggestion='Add examples', line_number=10, confidence=1.0, details={})

    def test_fix_invalid_example(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test fixing invalid examples."""
        mock_issue.issue_type = "example_invalid"

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._fix_invalid_example(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:471:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\example_generator.py:489: in _fix_invalid_example
    return self._generate_new_examples(context, "fix invalid example")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:512: in _generate_new_examples
    examples = generator.generate_examples(function, source_code, count=2)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:226: in generate_examples
    analysis = self.pattern_analyzer.analyze_function(function, source_code)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8AA77D0>
function = <Mock id='2300907148288'>
source_code = '\ndef calculate_area(width, height):\n    return width * height\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
_________ TestExampleSuggestionGenerator.test_update_outdated_example _________

self = <tests.suggestions.generators.test_example_generator.TestExampleSuggestionGenerator object at 0x00000217B8AB2190>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x00000217B8B95950>
mock_function = <Mock id='2300907149632'>
mock_docstring = <Mock id='2300907150640'>
mock_issue = InconsistencyIssue(issue_type='example_outdated', severity='low', description='Missing usage examples', suggestion='Add examples', line_number=10, confidence=1.0, details={})

    def test_update_outdated_example(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test updating outdated examples."""
        mock_issue.issue_type = "example_outdated"

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._update_outdated_example(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:490:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\example_generator.py:497: in _update_outdated_example
    return self._generate_new_examples(context, "update outdated example")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:512: in _generate_new_examples
    examples = generator.generate_examples(function, source_code, count=2)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:226: in generate_examples
    analysis = self.pattern_analyzer.analyze_function(function, source_code)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8E00050>
function = <Mock id='2300907149632'>
source_code = '\ndef calculate_area(width, height):\n    return width * height\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
____________ TestExampleSuggestionGenerator.test_complete_example _____________

self = <tests.suggestions.generators.test_example_generator.TestExampleSuggestionGenerator object at 0x00000217B8AB22C0>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x0000021795CCDBA0>
mock_function = <Mock id='2300905815552'>
mock_docstring = <Mock id='2300905814880'>
mock_issue = InconsistencyIssue(issue_type='example_incomplete', severity='low', description='Missing usage examples', suggestion='Add examples', line_number=10, confidence=1.0, details={})

    def test_complete_example(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test completing incomplete examples."""
        mock_issue.issue_type = "example_incomplete"

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._complete_example(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:509:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\example_generator.py:501: in _complete_example
    return self._generate_new_examples(context, "complete example")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:512: in _generate_new_examples
    examples = generator.generate_examples(function, source_code, count=2)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:226: in generate_examples
    analysis = self.pattern_analyzer.analyze_function(function, source_code)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8C8FEE0>
function = <Mock id='2300905815552'>
source_code = '\ndef calculate_area(width, height):\n    return width * height\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
_____ TestExampleSuggestionGenerator.test_no_examples_generated_fallback ______

self = <tests.suggestions.generators.test_example_generator.TestExampleSuggestionGenerator object at 0x00000217B8AA9D00>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x00000217979F3D10>
mock_function = <Mock id='2300905815216'>
mock_docstring = <Mock id='2300907147952'>
mock_issue = InconsistencyIssue(issue_type='example_invalid', severity='low', description='Missing usage examples', suggestion='Add examples', line_number=10, confidence=1.0, details={})

    def test_no_examples_generated_fallback(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test fallback when no examples can be generated."""
        # Function without signature
        mock_function.signature = None

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._add_missing_examples(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:547:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\example_generator.py:493: in _add_missing_examples
    return self._generate_new_examples(context, "add missing examples")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:512: in _generate_new_examples
    examples = generator.generate_examples(function, source_code, count=2)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:230: in generate_examples
    basic_example = self._generate_basic_example(function, analysis)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExampleGenerator object at 0x00000217B8B74050>
function = <Mock id='2300905815216'>
analysis = {'complexity': 'basic', 'domain': 'general', 'has_side_effects': False, 'is_async': False, ...}

    def _generate_basic_example(
        self, function: Any, analysis: dict[str, Any]
    ) -> ExampleTemplate | None:
        """Generate a basic usage example."""
        if not hasattr(function, "signature"):
            return None

        sig = function.signature
>       function_name = sig.name
                        ^^^^^^^^
E       AttributeError: 'NoneType' object has no attribute 'name'

codedocsync\suggestions\generators\example_generator.py:257: AttributeError
___________ TestExampleSuggestionGenerator.test_unknown_issue_type ____________

self = <tests.suggestions.generators.test_example_generator.TestExampleSuggestionGenerator object at 0x00000217B8AA9E10>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x00000217B8C3A140>
mock_function = <Mock id='2300907149968'>
mock_docstring = <Mock id='2300907145936'>

    def test_unknown_issue_type(
        self, generator: Any, mock_function: Mock, mock_docstring: Mock
    ) -> None:
        """Test handling unknown issue types."""
>       unknown_issue = InconsistencyIssue(
            issue_type="unknown_example_issue",
            severity="low",
            description="Unknown issue",
            suggestion="",
            line_number=10,
        )

tests\suggestions\generators\test_example_generator.py:556:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='unknown_example_issue', severity='low', description='Unknown issue', suggestion='', line_number=10, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
>           raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )
E           ValueError: issue_type must be one of ['parameter_name_mismatch', 'parameter_missing', 'parameter_type_mismatch', 'return_type_mismatch', 'missing_raises', 'parameter_order_different', 'description_outdated', 'example_invalid', 'missing_params', 'missing_returns', 'undocumented_kwargs', 'type_mismatches', 'default_mismatches', 'parameter_count_mismatch'], got 'unknown_example_issue'

codedocsync\analyzer\models.py:63: ValueError
_ TestExampleGeneratorIntegration.test_complete_workflow_mathematical_function _

self = <tests.suggestions.generators.test_example_generator.TestExampleGeneratorIntegration object at 0x00000217B8ABA490>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x00000217B8C3A9C0>

        def test_complete_workflow_mathematical_function(self, generator: Any) -> None:
            """Test complete workflow for mathematical function."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "calculate_distance"
            function.line_number = 5

            # Parameters
            x1_param: Mock = Mock()
            x1_param.name = "x1"
            x1_param.type_annotation = "float"
            x1_param.is_required = True
            x1_param.default_value = None

            y1_param: Mock = Mock()
            y1_param.name = "y1"
            y1_param.type_annotation = "float"
            y1_param.is_required = True
            y1_param.default_value = None

            x2_param: Mock = Mock()
            x2_param.name = "x2"
            x2_param.type_annotation = "float"
            x2_param.is_required = True
            x2_param.default_value = None

            y2_param: Mock = Mock()
            y2_param.name = "y2"
            y2_param.type_annotation = "float"
            y2_param.is_required = True
            y2_param.default_value = None

            function.signature.parameters = [x1_param, y1_param, x2_param, y2_param]
            function.source_code = """
    def calculate_distance(x1, y1, x2, y2):
        import math
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    """

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Calculate distance between two points"
            docstring.description = None
            docstring.parameters = []
            docstring.returns = None
            docstring.raises = []
            docstring.examples = []  # Missing examples
            docstring.raw_text = '"""Calculate distance between two points."""'

            issue = InconsistencyIssue(
                issue_type="example_invalid",
                severity="low",
                description="Function lacks usage examples",
                suggestion="Add examples",
                line_number=5,
            )

            context = SuggestionContext(function=function, docstring=docstring, issue=issue)

>           suggestion = generator.generate(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_example_generator.py:647:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\example_generator.py:477: in generate
    return self._fix_invalid_example(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:489: in _fix_invalid_example
    return self._generate_new_examples(context, "fix invalid example")
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:512: in _generate_new_examples
    examples = generator.generate_examples(function, source_code, count=2)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\example_generator.py:226: in generate_examples
    analysis = self.pattern_analyzer.analyze_function(function, source_code)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.example_generator.ExamplePatternAnalyzer object at 0x00000217B8DCC050>
function = <Mock id='2300907154000'>
source_code = '\ndef calculate_distance(x1, y1, x2, y2):\n    import math\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n'

    def analyze_function(self, function: Any, source_code: str = "") -> dict[str, Any]:
        """Analyze function to determine example characteristics."""
        analysis = {
            "is_property": False,
            "is_classmethod": False,
            "is_staticmethod": False,
            "is_async": False,
            "is_generator": False,
            "has_side_effects": False,
            "return_type": None,
            "complexity": "basic",
            "domain": "general",
        }

        # Analyze function signature
        if hasattr(function, "signature"):
            sig = function.signature

            # Check decorators
            if hasattr(sig, "decorators"):
                decorators = sig.decorators or []
>               analysis["is_property"] = "property" in decorators
                                          ^^^^^^^^^^^^^^^^^^^^^^^^
E               TypeError: argument of type 'Mock' is not iterable

codedocsync\suggestions\generators\example_generator.py:151: TypeError
_ TestExampleGeneratorIntegration.test_complete_workflow_file_processing_function _

self = <tests.suggestions.generators.test_example_generator.TestExampleGeneratorIntegration object at 0x00000217B8ABA5D0>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x00000217B8CE0350>

        def test_complete_workflow_file_processing_function(self, generator: Any) -> None:
            """Test complete workflow for file processing function."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "process_csv_file"
            function.line_number = 8

            # Parameters with meaningful names
            filepath_param: Mock = Mock()
            filepath_param.name = "filepath"
            filepath_param.type_annotation = "str"
            filepath_param.is_required = True
            filepath_param.default_value = None

            encoding_param: Mock = Mock()
            encoding_param.name = "encoding"
            encoding_param.type_annotation = "str"
            encoding_param.is_required = False
            encoding_param.default_value = "'utf-8'"

            function.signature.parameters = [filepath_param, encoding_param]
            function.source_code = """
    def process_csv_file(filepath, encoding='utf-8'):
        import csv
        with open(filepath, 'r', encoding=encoding) as f:
            return list(csv.reader(f))
    """

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Process CSV file and return rows"
            docstring.examples = []  # Missing examples
            docstring.raw_text = '"""Process CSV file and return rows."""'

>           issue = InconsistencyIssue(
                issue_type="example_invalid",
                severity="low",
                description="Add usage examples",
                suggestion="",
                line_number=8,
            )

tests\suggestions\generators\test_example_generator.py:700:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='example_invalid', severity='low', description='Add usage examples', suggestion='', line_number=8, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
            raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )

        # Validate severity
        valid_severities = ["critical", "high", "medium", "low"]
        if self.severity not in valid_severities:
            raise ValueError(
                f"severity must be one of {valid_severities}, got '{self.severity}'"
            )

        # Validate confidence
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(
                f"confidence must be between 0.0 and 1.0, got {self.confidence}"
            )

        # Validate line_number
        if self.line_number < 1:
            raise ValueError(f"line_number must be positive, got {self.line_number}")

        # Validate required strings are not empty
        if not self.description.strip():
            raise ValueError("description cannot be empty")

        if not self.suggestion.strip():
>           raise ValueError("suggestion cannot be empty")
E           ValueError: suggestion cannot be empty

codedocsync\analyzer\models.py:90: ValueError
___ TestExampleGeneratorIntegration.test_async_function_example_generation ____

self = <tests.suggestions.generators.test_example_generator.TestExampleGeneratorIntegration object at 0x00000217B8AB23F0>
generator = <codedocsync.suggestions.generators.example_generator.ExampleSuggestionGenerator object at 0x00000217B8CE0D50>

        def test_async_function_example_generation(self, generator: Any) -> None:
            """Test example generation for async functions."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "fetch_user_data"
            function.line_number = 3

            user_id_param: Mock = Mock()
            user_id_param.name = "user_id"
            user_id_param.type_annotation = "int"
            user_id_param.is_required = True
            user_id_param.default_value = None

            function.signature.parameters = [user_id_param]
            function.source_code = """
    async def fetch_user_data(user_id):
        async with aiohttp.ClientSession() as session:
            async with session.get(f"/users/{user_id}") as response:
                return await response.json()
    """

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Fetch user data asynchronously"
            docstring.examples = []
            docstring.raw_text = '"""Fetch user data asynchronously."""'

>           issue = InconsistencyIssue(
                issue_type="example_invalid",
                severity="low",
                description="Add async examples",
                suggestion="",
                line_number=3,
            )

tests\suggestions\generators\test_example_generator.py:754:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='example_invalid', severity='low', description='Add async examples', suggestion='', line_number=3, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
            raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )

        # Validate severity
        valid_severities = ["critical", "high", "medium", "low"]
        if self.severity not in valid_severities:
            raise ValueError(
                f"severity must be one of {valid_severities}, got '{self.severity}'"
            )

        # Validate confidence
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(
                f"confidence must be between 0.0 and 1.0, got {self.confidence}"
            )

        # Validate line_number
        if self.line_number < 1:
            raise ValueError(f"line_number must be positive, got {self.line_number}")

        # Validate required strings are not empty
        if not self.description.strip():
            raise ValueError("description cannot be empty")

        if not self.suggestion.strip():
>           raise ValueError("suggestion cannot be empty")
E           ValueError: suggestion cannot be empty

codedocsync\analyzer\models.py:90: ValueError
______ TestParameterSuggestionGenerator.test_fix_parameter_name_mismatch ______

self = <tests.suggestions.generators.test_parameter_generator.TestParameterSuggestionGenerator object at 0x00000217B8ABAAD0>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8C0FE00>
sample_function = ParsedFunction(signature=FunctionSignature(name='test_function', parameters=[FunctionParameter(name='param1', type_ann...test.py', line_number=10, end_line_number=20, source_code='def test_function(param1: str, param2: int = 0):\n    pass')
sample_docstring = ParsedDocstring(format=<DocstringFormat.GOOGLE: 'google'>, summary='Test function', description=None, parameters=[Docs...unction.\n\nArgs:\n    param1: First parameter\n    wrong_name: Second parameter\n"""', is_valid=True, parse_errors=[])

    def test_fix_parameter_name_mismatch(
        self, generator: Any, sample_function: Any, sample_docstring: Any
    ) -> None:
        """Test fixing parameter name mismatch."""
        issue = InconsistencyIssue(
            issue_type="parameter_name_mismatch",
            severity="critical",
            description="Parameter name mismatch",
            suggestion="Fix parameter name",
            line_number=10,
        )

        context = SuggestionContext(
            issue=issue, function=sample_function, docstring=sample_docstring
        )

        with patch("rapidfuzz.fuzz.ratio", return_value=85):
>           suggestion = generator.generate(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_parameter_generator.py:98:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\parameter_generator.py:33: in generate
    return self._fix_parameter_name(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\parameter_generator.py:68: in _fix_parameter_name
    corrected_docstring = self._generate_corrected_parameter_docstring(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8C0FE00>
context = SuggestionContext(issue=InconsistencyIssue(issue_type='parameter_name_mismatch', severity='critical', description='Par...'google', max_line_length=88, preserve_descriptions=True, surrounding_code=None, related_functions=[], file_imports=[])
mismatched_pairs = [('wrong_name', 'param2')]

    def _generate_corrected_parameter_docstring(
        self, context: SuggestionContext, mismatched_pairs: list[tuple]
    ) -> str:
        """Generate docstring with corrected parameter names."""
        docstring = context.docstring
        style = self._detect_style(docstring)
        style_enum = self._get_style_enum(style)
        template = get_template(style_enum, max_line_length=self.config.max_line_length)

        # Update parameter names
        corrected_params = []
        if (
            hasattr(docstring, "parameters")
            and docstring is not None
            and docstring.parameters
        ):
            for param in docstring.parameters:
                # Check if this parameter needs to be renamed
                new_name = param.name
                for old_name, correct_name in mismatched_pairs:
                    if param.name == old_name:
                        new_name = correct_name
                        break

                corrected_param = DocstringParameter(
                    name=new_name,
>                   type_str=param.type_annotation,
                             ^^^^^^^^^^^^^^^^^^^^^
                    description=param.description,
                    is_optional=param.is_optional,
                    default_value=param.default_value,
                )
E               AttributeError: 'DocstringParameter' object has no attribute 'type_annotation'

codedocsync\suggestions\generators\parameter_generator.py:356: AttributeError
__________ TestParameterSuggestionGenerator.test_fix_parameter_order __________

self = <tests.suggestions.generators.test_parameter_generator.TestParameterSuggestionGenerator object at 0x00000217B8AB29E0>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x0000021798B956E0>

    def test_fix_parameter_order(self, generator: Any) -> None:
        """Test fixing parameter order mismatch."""
        # Function with param1, param2 but docstring has param2, param1
        signature = FunctionSignature(
            name="test_function",
            parameters=[
                FunctionParameter(name="param1", type_annotation="str"),
                FunctionParameter(name="param2", type_annotation="int"),
            ],
        )

>       function = ParsedFunction(
            signature=signature, docstring=None, file_path="test.py", line_number=10
        )

tests\suggestions\generators\test_parameter_generator.py:186:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:9: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ParsedFunction(signature=FunctionSignature(name='test_function', parameters=[FunctionParameter(name='param1', type_ann...s_method=False, decorators=[]), docstring=None, file_path='test.py', line_number=10, end_line_number=0, source_code='')

    def __post_init__(self) -> None:
        """Validate parsed function data."""
        if self.line_number < 0:
            raise ValidationError(
                f"Invalid line number: {self.line_number}",
                recovery_hint="Line numbers must be positive integers",
            )

        if self.end_line_number < self.line_number:
>           raise ValidationError(
                f"End line ({self.end_line_number}) before start line ({self.line_number})",
                recovery_hint="End line number must be >= start line number",
            )
E           codedocsync.utils.errors.ValidationError: End line (0) before start line (10)

codedocsync\parser\ast_parser.py:159: ValidationError
_______ TestParameterSuggestionGenerator.test_add_kwargs_documentation ________

self = <tests.suggestions.generators.test_parameter_generator.TestParameterSuggestionGenerator object at 0x00000217B8B3A0F0>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8CB16E0>

    def test_add_kwargs_documentation(self, generator: Any) -> None:
        """Test adding **kwargs documentation."""
        signature = FunctionSignature(
            name="test_function",
            parameters=[
                FunctionParameter(name="param1", type_annotation="str"),
                FunctionParameter(name="**kwargs", type_annotation=None),
            ],
        )

>       function = ParsedFunction(
            signature=signature, docstring=None, file_path="test.py", line_number=10
        )

tests\suggestions\generators\test_parameter_generator.py:231:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:9: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ParsedFunction(signature=FunctionSignature(name='test_function', parameters=[FunctionParameter(name='param1', type_ann...s_method=False, decorators=[]), docstring=None, file_path='test.py', line_number=10, end_line_number=0, source_code='')

    def __post_init__(self) -> None:
        """Validate parsed function data."""
        if self.line_number < 0:
            raise ValidationError(
                f"Invalid line number: {self.line_number}",
                recovery_hint="Line numbers must be positive integers",
            )

        if self.end_line_number < self.line_number:
>           raise ValidationError(
                f"End line ({self.end_line_number}) before start line ({self.line_number})",
                recovery_hint="End line number must be >= start line number",
            )
E           codedocsync.utils.errors.ValidationError: End line (0) before start line (10)

codedocsync\parser\ast_parser.py:159: ValidationError
_______ TestParameterSuggestionGenerator.test_filter_special_parameters _______

self = <tests.suggestions.generators.test_parameter_generator.TestParameterSuggestionGenerator object at 0x00000217B8AAA030>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8AFD130>

    def test_filter_special_parameters(self, generator: Any) -> None:
        """Test filtering special parameters like self and cls."""
        # Test with self parameter (instance method)
        signature = FunctionSignature(
            name="test_method",
            parameters=[
                FunctionParameter(name="self"),
                FunctionParameter(name="param1", type_annotation="str"),
            ],
            is_method=True,
        )

>       function = ParsedFunction(
            signature=signature, docstring=None, file_path="test.py", line_number=10
        )

tests\suggestions\generators\test_parameter_generator.py:273:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:9: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ParsedFunction(signature=FunctionSignature(name='test_method', parameters=[FunctionParameter(name='self', type_annotat...is_method=True, decorators=[]), docstring=None, file_path='test.py', line_number=10, end_line_number=0, source_code='')

    def __post_init__(self) -> None:
        """Validate parsed function data."""
        if self.line_number < 0:
            raise ValidationError(
                f"Invalid line number: {self.line_number}",
                recovery_hint="Line numbers must be positive integers",
            )

        if self.end_line_number < self.line_number:
>           raise ValidationError(
                f"End line ({self.end_line_number}) before start line ({self.line_number})",
                recovery_hint="End line number must be >= start line number",
            )
E           codedocsync.utils.errors.ValidationError: End line (0) before start line (10)

codedocsync\parser\ast_parser.py:159: ValidationError
____________ TestParameterSuggestionGenerator.test_normalize_type _____________

self = <tests.suggestions.generators.test_parameter_generator.TestParameterSuggestionGenerator object at 0x00000217B8AD5B50>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x0000021795CA9050>

    def test_normalize_type(self, generator: Any) -> None:
        """Test type normalization."""
        assert generator._normalize_type("str") == "str"
>       assert generator._normalize_type("List[str]") == "list"
E       AssertionError: assert 'list[str]' == 'list'
E
E         - list
E         + list[str]

tests\suggestions\generators\test_parameter_generator.py:325: AssertionError
______ TestParameterSuggestionGenerator.test_detect_style_from_docstring ______

self = <tests.suggestions.generators.test_parameter_generator.TestParameterSuggestionGenerator object at 0x00000217B8B28230>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8B2B5C0>

    def test_detect_style_from_docstring(self, generator: Any) -> None:
        """Test detecting docstring style."""
        google_docstring = ParsedDocstring(
            format=DocstringFormat.GOOGLE, summary="Test"
        )

        style = generator._detect_style(google_docstring)
>       assert style == DocstringStyle.GOOGLE
E       AssertionError: assert 'google' == <DocstringStyle.GOOGLE: 'google'>
E        +  where <DocstringStyle.GOOGLE: 'google'> = DocstringStyle.GOOGLE

tests\suggestions\generators\test_parameter_generator.py:348: AssertionError
__________ TestParameterSuggestionGenerator.test_fallback_suggestion __________

self = <tests.suggestions.generators.test_parameter_generator.TestParameterSuggestionGenerator object at 0x00000217B8B418D0>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8D828A0>

    def test_fallback_suggestion(self, generator: Any) -> None:
        """Test fallback suggestion for unknown issues."""
>       issue = InconsistencyIssue(
            issue_type="unknown_issue",
            severity="low",
            description="Unknown issue",
            suggestion="Manual fix needed",
            line_number=10,
        )

tests\suggestions\generators\test_parameter_generator.py:352:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='unknown_issue', severity='low', description='Unknown issue', suggestion='Manual fix needed', line_number=10, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
>           raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )
E           ValueError: issue_type must be one of ['parameter_name_mismatch', 'parameter_missing', 'parameter_type_mismatch', 'return_type_mismatch', 'missing_raises', 'parameter_order_different', 'description_outdated', 'example_invalid', 'missing_params', 'missing_returns', 'undocumented_kwargs', 'type_mismatches', 'default_mismatches', 'parameter_count_mismatch'], got 'unknown_issue'

codedocsync\analyzer\models.py:63: ValueError
_________ TestParameterSuggestionGenerator.test_generic_parameter_fix _________

self = <tests.suggestions.generators.test_parameter_generator.TestParameterSuggestionGenerator object at 0x00000217B8B41B70>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8D1A190>

    def test_generic_parameter_fix(self, generator: Any) -> None:
        """Test generic parameter fix for unhandled issue types."""
>       issue = InconsistencyIssue(
            issue_type="unhandled_parameter_issue",
            severity="medium",
            description="Unhandled issue",
            suggestion="Fix manually",
            line_number=10,
        )

tests\suggestions\generators\test_parameter_generator.py:369:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='unhandled_parameter_issue', severity='medium', description='Unhandled issue', suggestion='Fix manually', line_number=10, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
>           raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )
E           ValueError: issue_type must be one of ['parameter_name_mismatch', 'parameter_missing', 'parameter_type_mismatch', 'return_type_mismatch', 'missing_raises', 'parameter_order_different', 'description_outdated', 'example_invalid', 'missing_params', 'missing_returns', 'undocumented_kwargs', 'type_mismatches', 'default_mismatches', 'parameter_count_mismatch'], got 'unhandled_parameter_issue'

codedocsync\analyzer\models.py:63: ValueError
_______ TestParameterGeneratorEdgeCases.test_empty_function_parameters ________

self = <tests.suggestions.generators.test_parameter_generator.TestParameterGeneratorEdgeCases object at 0x00000217B8ABAD50>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8D1AF90>

    def test_empty_function_parameters(self, generator: Any) -> None:
        """Test handling function with no parameters."""
        signature = FunctionSignature(name="test_function", parameters=[])
>       function = ParsedFunction(
            signature=signature, docstring=None, file_path="test.py", line_number=10
        )

tests\suggestions\generators\test_parameter_generator.py:397:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:9: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ParsedFunction(signature=FunctionSignature(name='test_function', parameters=[], return_type=None, is_async=False, is_method=False, decorators=[]), docstring=None, file_path='test.py', line_number=10, end_line_number=0, source_code='')

    def __post_init__(self) -> None:
        """Validate parsed function data."""
        if self.line_number < 0:
            raise ValidationError(
                f"Invalid line number: {self.line_number}",
                recovery_hint="Line numbers must be positive integers",
            )

        if self.end_line_number < self.line_number:
>           raise ValidationError(
                f"End line ({self.end_line_number}) before start line ({self.line_number})",
                recovery_hint="End line number must be >= start line number",
            )
E           codedocsync.utils.errors.ValidationError: End line (0) before start line (10)

codedocsync\parser\ast_parser.py:159: ValidationError
_________ TestParameterGeneratorEdgeCases.test_classmethod_detection __________

self = <tests.suggestions.generators.test_parameter_generator.TestParameterGeneratorEdgeCases object at 0x00000217B8B64050>
generator = <codedocsync.suggestions.generators.parameter_generator.ParameterSuggestionGenerator object at 0x00000217B8E559C0>

    def test_classmethod_detection(self, generator: Any) -> None:
        """Test detection of classmethod decorator."""
        signature = FunctionSignature(
            name="test_classmethod",
            decorators=["classmethod"],
            parameters=[
                FunctionParameter(name="cls"),
                FunctionParameter(name="param1", type_annotation="str"),
            ],
        )

>       function = ParsedFunction(
            signature=signature, docstring=None, file_path="test.py", line_number=10
        )

tests\suggestions\generators\test_parameter_generator.py:442:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:9: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ParsedFunction(signature=FunctionSignature(name='test_classmethod', parameters=[FunctionParameter(name='cls', type_ann...e, decorators=['classmethod']), docstring=None, file_path='test.py', line_number=10, end_line_number=0, source_code='')

    def __post_init__(self) -> None:
        """Validate parsed function data."""
        if self.line_number < 0:
            raise ValidationError(
                f"Invalid line number: {self.line_number}",
                recovery_hint="Line numbers must be positive integers",
            )

        if self.end_line_number < self.line_number:
>           raise ValidationError(
                f"End line ({self.end_line_number}) before start line ({self.line_number})",
                recovery_hint="End line number must be >= start line number",
            )
E           codedocsync.utils.errors.ValidationError: End line (0) before start line (10)

codedocsync\parser\ast_parser.py:159: ValidationError
_____ TestRaisesSuggestionGenerator.test_add_missing_raises_documentation _____

self = <tests.suggestions.generators.test_raises_generator.TestRaisesSuggestionGenerator object at 0x00000217B8ABB4D0>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8C0FB60>
mock_function = <Mock id='2300907158032'>
mock_docstring = <Mock id='2300907155680'>
mock_issue = InconsistencyIssue(issue_type='missing_raises', severity='medium', description='Missing exception documentation', suggestion='Add raises documentation', line_number=10, confidence=1.0, details={})

    def test_add_missing_raises_documentation(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test adding missing raises documentation."""
        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._add_missing_raises_documentation(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_raises_generator.py:213:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\raises_generator.py:286: in _add_missing_raises_documentation
    updated_docstring = self._add_exceptions_to_docstring(
codedocsync\suggestions\generators\raises_generator.py:468: in _add_exceptions_to_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8C0FB60>
docstring = <Mock id='2300907155680'>

    def _detect_style(self, docstring: Any) -> DocstringStyle:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Convert string to DocstringStyle enum
>           style_value = docstring.format.value
                          ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\raises_generator.py:514: AttributeError
_________ TestRaisesSuggestionGenerator.test_fix_raises_type_mismatch _________

self = <tests.suggestions.generators.test_raises_generator.TestRaisesSuggestionGenerator object at 0x00000217B8ABB610>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8B94B90>
mock_function = <Mock id='2300907156688'>
mock_docstring = <Mock id='2300907146944'>
mock_issue = InconsistencyIssue(issue_type='raises_type_mismatch', severity='medium', description='Missing exception documentation', suggestion='Add raises documentation', line_number=10, confidence=1.0, details={})

    def test_fix_raises_type_mismatch(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test fixing raises type mismatch."""
        # Add existing (incorrect) raises documentation
        mock_docstring.raises = [
            DocstringRaises(
                exception_type="RuntimeError", description="Wrong exception"
            ),
            DocstringRaises(
                exception_type="ValueError", description="Correct exception"
            ),
        ]
        mock_issue.issue_type = "raises_type_mismatch"

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._fix_raises_type_mismatch(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_raises_generator.py:248:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\raises_generator.py:357: in _fix_raises_type_mismatch
    corrected_docstring = self._update_raises_in_docstring(
codedocsync\suggestions\generators\raises_generator.py:498: in _update_raises_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8B94B90>
docstring = <Mock id='2300907146944'>

    def _detect_style(self, docstring: Any) -> DocstringStyle:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Convert string to DocstringStyle enum
>           style_value = docstring.format.value
                          ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\raises_generator.py:514: AttributeError
________ TestRaisesSuggestionGenerator.test_improve_raises_description ________

self = <tests.suggestions.generators.test_raises_generator.TestRaisesSuggestionGenerator object at 0x00000217B8AB3230>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8B97890>
mock_function = <Mock id='2300907153664'>
mock_docstring = <Mock id='2300907154672'>
mock_issue = InconsistencyIssue(issue_type='missing_raises', severity='medium', description='Missing exception documentation', suggestion='Add raises documentation', line_number=10, confidence=1.0, details={})

    def test_improve_raises_description(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test improving vague raises descriptions."""
        mock_docstring.raises = [
            DocstringRaises(exception_type="ValueError", description="error"),
            DocstringRaises(exception_type="TypeError", description="failure"),
        ]
        mock_issue.issue_type = "missing_raises"

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._improve_raises_description(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_raises_generator.py:275:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\raises_generator.py:414: in _improve_raises_description
    updated_docstring = self._update_raises_in_docstring(context, improved_raises)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\raises_generator.py:498: in _update_raises_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8B97890>
docstring = <Mock id='2300907154672'>

    def _detect_style(self, docstring: Any) -> DocstringStyle:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Convert string to DocstringStyle enum
>           style_value = docstring.format.value
                          ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\raises_generator.py:514: AttributeError
___________ TestRaisesSuggestionGenerator.test_is_vague_description ___________

self = <tests.suggestions.generators.test_raises_generator.TestRaisesSuggestionGenerator object at 0x00000217B8AB3360>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8CB2060>

    def test_is_vague_description(self, generator: Any) -> None:
        """Test detection of vague exception descriptions."""
        # Test vague descriptions
        assert generator._is_vague_description("error")
        assert generator._is_vague_description("exception")
        assert generator._is_vague_description("failure")
>       assert generator._is_vague_description("when error occurs")
E       AssertionError: assert False
E        +  where False = _is_vague_description('when error occurs')
E        +    where _is_vague_description = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8CB2060>._is_vague_description

tests\suggestions\generators\test_raises_generator.py:291: AssertionError
_________ TestRaisesSuggestionGenerator.test_no_source_code_fallback __________

self = <tests.suggestions.generators.test_raises_generator.TestRaisesSuggestionGenerator object at 0x00000217B8AAA9C0>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8DC8170>
mock_function = <Mock id='2300907155344'>
mock_docstring = <Mock id='2300907155008'>
mock_issue = InconsistencyIssue(issue_type='missing_raises', severity='medium', description='Missing exception documentation', suggestion='Add raises documentation', line_number=10, confidence=1.0, details={})

    def test_no_source_code_fallback(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test fallback when source code is not available."""
        mock_function.source_code = ""

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._add_missing_raises_documentation(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_raises_generator.py:339:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\raises_generator.py:267: in _add_missing_raises_documentation
    return self._create_fallback_suggestion(
codedocsync\suggestions\generators\raises_generator.py:563: in _create_fallback_suggestion
    return self._create_suggestion(
codedocsync\suggestions\generators\raises_generator.py:555: in _create_suggestion
    style=self._detect_style(context.docstring).value,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8DC8170>
docstring = <Mock id='2300907155008'>

    def _detect_style(self, docstring: Any) -> DocstringStyle:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Convert string to DocstringStyle enum
>           style_value = docstring.format.value
                          ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\raises_generator.py:514: AttributeError
________ TestRaisesSuggestionGenerator.test_no_significant_exceptions _________

self = <tests.suggestions.generators.test_raises_generator.TestRaisesSuggestionGenerator object at 0x00000217B8AAAAD0>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8C3B9B0>
mock_function = <Mock id='2300907154672'>
mock_docstring = <Mock id='2300907143920'>
mock_issue = InconsistencyIssue(issue_type='missing_raises', severity='medium', description='Missing exception documentation', suggestion='Add raises documentation', line_number=10, confidence=1.0, details={})

        def test_no_significant_exceptions(
            self,
            generator: Any,
            mock_function: Mock,
            mock_docstring: Mock,
            mock_issue: InconsistencyIssue,
        ) -> None:
            """Test handling when no significant exceptions are detected."""
            # Function with only very low-confidence exceptions
            mock_function.source_code = """
    def simple_func():
        return "hello"
    """

            context = SuggestionContext(
                function=mock_function, docstring=mock_docstring, issue=mock_issue
            )

>           suggestion = generator._add_missing_raises_documentation(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_raises_generator.py:362:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\raises_generator.py:281: in _add_missing_raises_documentation
    return self._create_fallback_suggestion(
codedocsync\suggestions\generators\raises_generator.py:563: in _create_fallback_suggestion
    return self._create_suggestion(
codedocsync\suggestions\generators\raises_generator.py:555: in _create_suggestion
    style=self._detect_style(context.docstring).value,
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8C3B9B0>
docstring = <Mock id='2300907143920'>

    def _detect_style(self, docstring: Any) -> DocstringStyle:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Convert string to DocstringStyle enum
>           style_value = docstring.format.value
                          ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\raises_generator.py:514: AttributeError
____________ TestRaisesSuggestionGenerator.test_unknown_issue_type ____________

self = <tests.suggestions.generators.test_raises_generator.TestRaisesSuggestionGenerator object at 0x00000217B8AD6250>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8C38E20>
mock_function = <Mock id='2300907146272'>
mock_docstring = <Mock id='2300907155680'>

    def test_unknown_issue_type(
        self, generator: Any, mock_function: Mock, mock_docstring: Mock
    ) -> None:
        """Test handling unknown issue types."""
>       unknown_issue = InconsistencyIssue(
            issue_type="unknown_raises_issue",
            severity="medium",
            description="Unknown issue",
            suggestion="",
            line_number=10,
        )

tests\suggestions\generators\test_raises_generator.py:371:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='unknown_raises_issue', severity='medium', description='Unknown issue', suggestion='', line_number=10, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
>           raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )
E           ValueError: issue_type must be one of ['parameter_name_mismatch', 'parameter_missing', 'parameter_type_mismatch', 'return_type_mismatch', 'missing_raises', 'parameter_order_different', 'description_outdated', 'example_invalid', 'missing_params', 'missing_returns', 'undocumented_kwargs', 'type_mismatches', 'default_mismatches', 'parameter_count_mismatch'], got 'unknown_raises_issue'

codedocsync\analyzer\models.py:63: ValueError
____ TestRaisesGeneratorIntegration.test_complete_workflow_file_operations ____

self = <tests.suggestions.generators.test_raises_generator.TestRaisesGeneratorIntegration object at 0x00000217B8ABB750>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8AD7D50>

        def test_complete_workflow_file_operations(self, generator: Any) -> None:
            """Test complete workflow for file operations function."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "read_config_file"
            function.line_number = 5
            function.source_code = """
    def read_config_file(filename):
        if not filename:
            raise ValueError("Filename cannot be empty")

        try:
            with open(filename, 'r') as f:
                content = f.read()
        except FileNotFoundError:
            raise FileNotFoundError(f"Config file {filename} not found")
        except PermissionError:
            raise PermissionError(f"Permission denied: {filename}")

        try:
            import json
            return json.loads(content)
        except json.JSONDecodeError:
            raise ValueError(f"Invalid JSON in {filename}")
    """

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Read configuration from file"
            docstring.description = None
            docstring.parameters = []
            docstring.returns = None
            docstring.raises = []  # Missing raises documentation
            docstring.examples = []
            docstring.raw_text = '"""Read configuration from file."""'

            issue = InconsistencyIssue(
                issue_type="missing_raises",
                severity="medium",
                description="Missing exception documentation",
                suggestion="Document exceptions",
                line_number=5,
            )

            context = SuggestionContext(function=function, docstring=docstring, issue=issue)

>           suggestion = generator.generate(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_raises_generator.py:449:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\raises_generator.py:248: in generate
    return self._add_missing_raises_documentation(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\raises_generator.py:286: in _add_missing_raises_documentation
    updated_docstring = self._add_exceptions_to_docstring(
codedocsync\suggestions\generators\raises_generator.py:468: in _add_exceptions_to_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8AD7D50>
docstring = <Mock id='2300907156016'>

    def _detect_style(self, docstring: Any) -> DocstringStyle:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Convert string to DocstringStyle enum
>           style_value = docstring.format.value
                          ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\raises_generator.py:514: AttributeError
__ TestRaisesGeneratorIntegration.test_complete_workflow_mismatch_correction __

self = <tests.suggestions.generators.test_raises_generator.TestRaisesGeneratorIntegration object at 0x00000217B8ABB890>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8CE0D50>

        def test_complete_workflow_mismatch_correction(self, generator: Any) -> None:
            """Test complete workflow for correcting exception mismatches."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "validate_input"
            function.line_number = 8
            function.source_code = """
    def validate_input(data):
        if not isinstance(data, dict):
            raise TypeError("Expected dictionary")
        if 'required_field' not in data:
            raise ValueError("Missing required field")
        return True
    """

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Validate input data"
            docstring.raises = [
                # Incorrect exception documented
                DocstringRaises(
                    exception_type="RuntimeError", description="When validation fails"
                ),
                # Missing TypeError, has ValueError but different description
                DocstringRaises(exception_type="ValueError", description="Old description"),
            ]
            docstring.parameters = []
            docstring.returns = None
            docstring.examples = []
            docstring.raw_text = '"""Validate input data."""'

>           issue = InconsistencyIssue(
                issue_type="raises_type_mismatch",
                severity="high",
                description="Exception type mismatch",
                suggestion="Fix documented exceptions",
                line_number=8,
            )

tests\suggestions\generators\test_raises_generator.py:495:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='raises_type_mismatch', severity='high', description='Exception type mismatch', suggestion='Fix documented exceptions', line_number=8, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
>           raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )
E           ValueError: issue_type must be one of ['parameter_name_mismatch', 'parameter_missing', 'parameter_type_mismatch', 'return_type_mismatch', 'missing_raises', 'parameter_order_different', 'description_outdated', 'example_invalid', 'missing_params', 'missing_returns', 'undocumented_kwargs', 'type_mismatches', 'default_mismatches', 'parameter_count_mismatch'], got 'raises_type_mismatch'

codedocsync\analyzer\models.py:63: ValueError
____ TestRaisesGeneratorIntegration.test_edge_case_no_exceptions_detected _____

self = <tests.suggestions.generators.test_raises_generator.TestRaisesGeneratorIntegration object at 0x00000217B8AB3490>
generator = <codedocsync.suggestions.generators.raises_generator.RaisesSuggestionGenerator object at 0x00000217B8D814F0>

        def test_edge_case_no_exceptions_detected(self, generator: Any) -> None:
            """Test edge case where no exceptions are detected."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "simple_getter"
            function.line_number = 3
            function.source_code = """
    def simple_getter(self):
        return self._value
    """

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Get the value"
            docstring.raises = []
            docstring.raw_text = '"""Get the value."""'

>           issue = InconsistencyIssue(
                issue_type="missing_raises",
                severity="low",
                description="Check for exceptions",
                suggestion="",
                line_number=3,
            )

tests\suggestions\generators\test_raises_generator.py:538:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='missing_raises', severity='low', description='Check for exceptions', suggestion='', line_number=3, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
            raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )

        # Validate severity
        valid_severities = ["critical", "high", "medium", "low"]
        if self.severity not in valid_severities:
            raise ValueError(
                f"severity must be one of {valid_severities}, got '{self.severity}'"
            )

        # Validate confidence
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(
                f"confidence must be between 0.0 and 1.0, got {self.confidence}"
            )

        # Validate line_number
        if self.line_number < 1:
            raise ValueError(f"line_number must be positive, got {self.line_number}")

        # Validate required strings are not empty
        if not self.description.strip():
            raise ValueError("description cannot be empty")

        if not self.suggestion.strip():
>           raise ValueError("suggestion cannot be empty")
E           ValueError: suggestion cannot be empty

codedocsync\analyzer\models.py:90: ValueError
_________ TestReturnStatementAnalyzer.test_analyze_generator_function _________

self = <tests.suggestions.generators.test_return_generator.TestReturnStatementAnalyzer object at 0x00000217B8AB3820>

        def test_analyze_generator_function(self) -> None:
            """Test analyzing generator function."""
            source_code = """
    def test_func() -> None:
        for i in range(10):
            yield i
    """
            analyzer = ReturnStatementAnalyzer()
            result = analyzer.analyze(source_code)

            assert result.is_generator
>           assert "Generator[int]" in result.return_types
E           AssertionError: assert 'Generator[int]' in set()
E            +  where set() = <codedocsync.suggestions.generators.return_generator.ReturnAnalysisResult object at 0x00000217B8B94B90>.return_types

tests\suggestions\generators\test_return_generator.py:74: AssertionError
_________ TestReturnSuggestionGenerator.test_fix_return_type_mismatch _________

self = <tests.suggestions.generators.test_return_generator.TestReturnSuggestionGenerator object at 0x00000217B8ABBC50>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8C0D160>
mock_function = <Mock id='2300907148288'>
mock_docstring = <Mock id='2300905814880'>
mock_issue = InconsistencyIssue(issue_type='return_type_mismatch', severity='high', description='Return type mismatch', suggestion='Fix return type', line_number=10, confidence=1.0, details={})

    def test_fix_return_type_mismatch(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test fixing return type mismatch."""
        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._fix_return_type(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_return_generator.py:182:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\return_generator.py:172: in _fix_return_type
    corrected_docstring = self._update_return_type_in_docstring(
codedocsync\suggestions\generators\return_generator.py:346: in _update_return_type_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8C0D160>
docstring = <Mock id='2300905814880'>

    def _detect_style(self, docstring: Any) -> str:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\return_generator.py:483: AttributeError
_____ TestReturnSuggestionGenerator.test_add_missing_return_documentation _____

self = <tests.suggestions.generators.test_return_generator.TestReturnSuggestionGenerator object at 0x00000217B8ABBD90>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8B95810>
mock_function = <Mock id='2300905813872'>
mock_docstring = <Mock id='2300905811520'>
mock_issue = InconsistencyIssue(issue_type='missing_returns', severity='high', description='Return type mismatch', suggestion='Fix return type', line_number=10, confidence=1.0, details={})

    def test_add_missing_return_documentation(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test adding missing return documentation."""
        mock_issue.issue_type = "missing_returns"
        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._add_missing_return_documentation(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_return_generator.py:202:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\return_generator.py:209: in _add_missing_return_documentation
    updated_docstring = self._add_return_to_docstring(context, suggested_type)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\return_generator.py:369: in _add_return_to_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8B95810>
docstring = <Mock id='2300905811520'>

    def _detect_style(self, docstring: Any) -> str:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\return_generator.py:483: AttributeError
________ TestReturnSuggestionGenerator.test_improve_return_description ________

self = <tests.suggestions.generators.test_return_generator.TestReturnSuggestionGenerator object at 0x00000217B8AB3A80>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8B979D0>
mock_function = <Mock id='2300907148288'>
mock_docstring = <Mock id='2300907143584'>
mock_issue = InconsistencyIssue(issue_type='return_type_mismatch', severity='high', description='Return type mismatch', suggestion='Fix return type', line_number=10, confidence=1.0, details={})

    def test_improve_return_description(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test improving vague return description."""
        mock_docstring.returns = DocstringReturns(type_str="str", description="result")
        mock_issue.issue_type = "return_type_mismatch"

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._improve_return_description(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_return_generator.py:226:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\return_generator.py:246: in _improve_return_description
    updated_docstring = self._update_return_description_in_docstring(
codedocsync\suggestions\generators\return_generator.py:456: in _update_return_description_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8B979D0>
docstring = <Mock id='2300907143584'>

    def _detect_style(self, docstring: Any) -> str:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\return_generator.py:483: AttributeError
___________ TestReturnSuggestionGenerator.test_fix_generator_return ___________

self = <tests.suggestions.generators.test_return_generator.TestReturnSuggestionGenerator object at 0x00000217B8AB3BB0>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8AB0C30>
mock_function = <Mock id='2300907147952'>
mock_docstring = <Mock id='2300907150976'>
mock_issue = InconsistencyIssue(issue_type='generator_return_incorrect', severity='high', description='Return type mismatch', suggestion='Fix return type', line_number=10, confidence=1.0, details={})

        def test_fix_generator_return(
            self,
            generator: Any,
            mock_function: Mock,
            mock_docstring: Mock,
            mock_issue: InconsistencyIssue,
        ) -> None:
            """Test fixing generator return documentation."""
            mock_function.source_code = """
    def test_function() -> None:
        for i in range(10):
            yield i
    """
            mock_issue.issue_type = "generator_return_incorrect"

            context = SuggestionContext(
                function=mock_function, docstring=mock_docstring, issue=mock_issue
            )

>           suggestion = generator._fix_generator_return(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_return_generator.py:250:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\return_generator.py:291: in _fix_generator_return
    updated_docstring = self._update_return_type_in_docstring(
codedocsync\suggestions\generators\return_generator.py:346: in _update_return_type_in_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8AB0C30>
docstring = <Mock id='2300907150976'>

    def _detect_style(self, docstring: Any) -> str:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\return_generator.py:483: AttributeError
____ TestReturnSuggestionGenerator.test_determine_best_return_type_single _____

self = <tests.suggestions.generators.test_return_generator.TestReturnSuggestionGenerator object at 0x00000217B8B66210>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8CB28B0>

    def test_determine_best_return_type_single(self, generator: Any) -> None:
        """Test determining best return type with single type."""
        analysis = ReturnAnalysisResult()
        analysis.return_types = {"str"}
        analysis.is_generator = False
        analysis.has_implicit_none = False

        mock_function: Mock = Mock()
        mock_function.signature.return_annotation = None

        result = generator._determine_best_return_type(analysis, mock_function)
>       assert result == "str"
E       AssertionError: assert 'None' == 'str'
E
E         - str
E         + None

tests\suggestions\generators\test_return_generator.py:267: AssertionError
___ TestReturnSuggestionGenerator.test_determine_best_return_type_multiple ____

self = <tests.suggestions.generators.test_return_generator.TestReturnSuggestionGenerator object at 0x00000217B8AAB680>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8DC9130>

    def test_determine_best_return_type_multiple(self, generator: Any) -> None:
        """Test determining best return type with multiple types."""
        analysis = ReturnAnalysisResult()
        analysis.return_types = {"str", "int"}
        analysis.is_generator = False
        analysis.has_implicit_none = False

        mock_function: Mock = Mock()
        mock_function.signature.return_annotation = None

        result = generator._determine_best_return_type(analysis, mock_function)
>       assert "Union" in result
E       AssertionError: assert 'Union' in 'None'

tests\suggestions\generators\test_return_generator.py:280: AssertionError
_________ TestReturnSuggestionGenerator.test_no_source_code_fallback __________

self = <tests.suggestions.generators.test_return_generator.TestReturnSuggestionGenerator object at 0x00000217B8B289B0>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8CE2550>
mock_function = <Mock id='2300907157696'>
mock_docstring = <Mock id='2300907155680'>
mock_issue = InconsistencyIssue(issue_type='return_type_mismatch', severity='high', description='Return type mismatch', suggestion='Fix return type', line_number=10, confidence=1.0, details={})

    def test_no_source_code_fallback(
        self,
        generator: Any,
        mock_function: Mock,
        mock_docstring: Mock,
        mock_issue: InconsistencyIssue,
    ) -> None:
        """Test fallback when source code is not available."""
        mock_function.source_code = ""

        context = SuggestionContext(
            function=mock_function, docstring=mock_docstring, issue=mock_issue
        )

>       suggestion = generator._fix_return_type(context)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_return_generator.py:335:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\return_generator.py:157: in _fix_return_type
    return self._create_fallback_suggestion(
codedocsync\suggestions\generators\return_generator.py:531: in _create_fallback_suggestion
    return self._create_suggestion(
codedocsync\suggestions\generators\return_generator.py:523: in _create_suggestion
    style=self._detect_style(context.docstring),
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8CE2550>
docstring = <Mock id='2300907155680'>

    def _detect_style(self, docstring: Any) -> str:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\return_generator.py:483: AttributeError
____________ TestReturnSuggestionGenerator.test_unknown_issue_type ____________

self = <tests.suggestions.generators.test_return_generator.TestReturnSuggestionGenerator object at 0x00000217B8B28B90>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8B28D70>
mock_function = <Mock id='2300907158032'>
mock_docstring = <Mock id='2300907143920'>

    def test_unknown_issue_type(
        self, generator: Any, mock_function: Mock, mock_docstring: Mock
    ) -> None:
        """Test handling unknown issue types."""
>       unknown_issue = InconsistencyIssue(
            issue_type="unknown_return_issue",
            severity="medium",
            description="Unknown issue",
            suggestion="",
            line_number=10,
        )

tests\suggestions\generators\test_return_generator.py:344:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='unknown_return_issue', severity='medium', description='Unknown issue', suggestion='', line_number=10, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
>           raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )
E           ValueError: issue_type must be one of ['parameter_name_mismatch', 'parameter_missing', 'parameter_type_mismatch', 'return_type_mismatch', 'missing_raises', 'parameter_order_different', 'description_outdated', 'example_invalid', 'missing_params', 'missing_returns', 'undocumented_kwargs', 'type_mismatches', 'default_mismatches', 'parameter_count_mismatch'], got 'unknown_return_issue'

codedocsync\analyzer\models.py:63: ValueError
____ TestReturnGeneratorIntegration.test_complete_workflow_missing_returns ____

self = <tests.suggestions.generators.test_return_generator.TestReturnGeneratorIntegration object at 0x00000217B8ABBED0>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8E84410>

        def test_complete_workflow_missing_returns(self, generator: Any) -> None:
            """Test complete workflow for missing returns."""
            # Create realistic function and docstring
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "calculate_sum"
            function.signature.return_annotation = "int"
            function.line_number = 5
            function.source_code = """
    def calculate_sum(a, b):
        return a + b
    """

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Calculate sum of two numbers"
            docstring.description = None
            docstring.parameters = []
            docstring.returns = None  # Missing returns
            docstring.raises = []
            docstring.examples = []
            docstring.raw_text = '"""Calculate sum of two numbers."""'

            issue = InconsistencyIssue(
                issue_type="missing_returns",
                severity="high",
                description="Missing return documentation",
                suggestion="Add return documentation",
                line_number=5,
            )

            context = SuggestionContext(function=function, docstring=docstring, issue=issue)

>           suggestion = generator.generate(context)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\suggestions\generators\test_return_generator.py:409:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
codedocsync\suggestions\generators\return_generator.py:141: in generate
    return self._add_missing_return_documentation(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\return_generator.py:209: in _add_missing_return_documentation
    updated_docstring = self._add_return_to_docstring(context, suggested_type)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
codedocsync\suggestions\generators\return_generator.py:369: in _add_return_to_docstring
    style = self._detect_style(docstring)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8E84410>
docstring = <Mock id='2300907153664'>

    def _detect_style(self, docstring: Any) -> str:
        """Detect docstring style from parsed docstring."""
        if hasattr(docstring, "format"):
            # Return the string format directly
>           return str(docstring.format.value)
                       ^^^^^^^^^^^^^^^^^^^^^^
E           AttributeError: 'str' object has no attribute 'value'

codedocsync\suggestions\generators\return_generator.py:483: AttributeError
__ TestReturnGeneratorIntegration.test_complete_workflow_generator_function ___

self = <tests.suggestions.generators.test_return_generator.TestReturnGeneratorIntegration object at 0x00000217B8B94050>
generator = <codedocsync.suggestions.generators.return_generator.ReturnSuggestionGenerator object at 0x00000217B8EB9A90>

        def test_complete_workflow_generator_function(self, generator: Any) -> None:
            """Test complete workflow for generator function."""
            function: Mock = Mock()
            function.signature = Mock()
            function.signature.name = "number_generator"
            function.signature.return_annotation = None
            function.line_number = 8
            function.source_code = """
    def number_generator(n):
        for i in range(n):
            yield i * 2
    """

            docstring: Mock = Mock()
            docstring.format = "google"
            docstring.summary = "Generate numbers"
            docstring.returns = DocstringReturns(
                type_str="list", description="List of numbers"
            )  # Wrong for generator
            docstring.parameters = []
            docstring.raises = []
            docstring.examples = []
            docstring.raw_text = '"""Generate numbers."""'

>           issue = InconsistencyIssue(
                issue_type="generator_return_incorrect",
                severity="high",
                description="Generator return type incorrect",
                suggestion="Fix generator return",
                line_number=8,
            )

tests\suggestions\generators\test_return_generator.py:447:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:10: in __init__
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = InconsistencyIssue(issue_type='generator_return_incorrect', severity='high', description='Generator return type incorrect', suggestion='Fix generator return', line_number=8, confidence=1.0, details={})

    def __post_init__(self) -> None:
        """Validate issue fields."""
        # Validate issue_type
        if self.issue_type not in ISSUE_TYPES:
>           raise ValueError(
                f"issue_type must be one of {list(ISSUE_TYPES.keys())}, "
                f"got '{self.issue_type}'"
            )
E           ValueError: issue_type must be one of ['parameter_name_mismatch', 'parameter_missing', 'parameter_type_mismatch', 'return_type_mismatch', 'missing_raises', 'parameter_order_different', 'description_outdated', 'example_invalid', 'missing_params', 'missing_returns', 'undocumented_kwargs', 'type_mismatches', 'default_mismatches', 'parameter_count_mismatch'], got 'generator_return_incorrect'

codedocsync\analyzer\models.py:63: ValueError
=========================== short test summary info ===========================
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_data_operations
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_error_handling
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorAnalyzer::test_analyze_performance_characteristics
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_improve_vague_description
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_improve_outdated_description
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_add_behavior_description
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_add_side_effects_documentation
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_no_source_code_fallback
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_no_patterns_detected
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorSuggestionGenerator::test_unknown_issue_type
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorGeneratorIntegration::test_complete_workflow_data_processing
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorGeneratorIntegration::test_complete_workflow_file_operations
FAILED tests/suggestions/generators/test_behavior_generator.py::TestBehaviorGeneratorIntegration::test_performance_pattern_detection
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestSpecialConstructAnalyzer::test_analyze_property_getter
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestSpecialConstructAnalyzer::test_analyze_classmethod
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestSpecialConstructAnalyzer::test_analyze_magic_method
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestSpecialConstructAnalyzer::test_analyze_async_function
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestPropertyMethodHandler::test_generate_property_getter_docstring
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestPropertyMethodHandler::test_property_setter_detection
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestPropertyMethodHandler::test_property_deleter_detection
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestClassMethodHandler::test_generate_classmethod_docstring
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestClassMethodHandler::test_staticmethod_handling
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestEdgeCaseSuggestionGenerator::test_generate_no_special_constructs
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestEdgeCaseSuggestionGenerator::test_async_function_suggestion
FAILED tests/suggestions/generators/test_edge_case_handlers.py::TestEdgeCaseSuggestionGenerator::test_magic_method_suggestion
FAILED tests/suggestions/generators/test_example_generator.py::TestParameterValueGenerator::test_generate_value_by_name
FAILED tests/suggestions/generators/test_example_generator.py::TestParameterValueGenerator::test_generate_value_optional_with_default
FAILED tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_async_function
FAILED tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_generator_function
FAILED tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_side_effects
FAILED tests/suggestions/generators/test_example_generator.py::TestExamplePatternAnalyzer::test_analyze_domain_detection
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_async_example
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_property_example
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_edge_case_values
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_expected_output
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleGenerator::test_generate_multiple_examples
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_add_missing_examples
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_fix_invalid_example
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_update_outdated_example
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_complete_example
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_no_examples_generated_fallback
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleSuggestionGenerator::test_unknown_issue_type
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleGeneratorIntegration::test_complete_workflow_mathematical_function
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleGeneratorIntegration::test_complete_workflow_file_processing_function
FAILED tests/suggestions/generators/test_example_generator.py::TestExampleGeneratorIntegration::test_async_function_example_generation
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_fix_parameter_name_mismatch
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_fix_parameter_order
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_add_kwargs_documentation
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_filter_special_parameters
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_normalize_type
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_detect_style_from_docstring
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_fallback_suggestion
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterSuggestionGenerator::test_generic_parameter_fix
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterGeneratorEdgeCases::test_empty_function_parameters
FAILED tests/suggestions/generators/test_parameter_generator.py::TestParameterGeneratorEdgeCases::test_classmethod_detection
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_add_missing_raises_documentation
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_fix_raises_type_mismatch
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_improve_raises_description
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_is_vague_description
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_no_source_code_fallback
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_no_significant_exceptions
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesSuggestionGenerator::test_unknown_issue_type
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesGeneratorIntegration::test_complete_workflow_file_operations
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesGeneratorIntegration::test_complete_workflow_mismatch_correction
FAILED tests/suggestions/generators/test_raises_generator.py::TestRaisesGeneratorIntegration::test_edge_case_no_exceptions_detected
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnStatementAnalyzer::test_analyze_generator_function
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_fix_return_type_mismatch
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_add_missing_return_documentation
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_improve_return_description
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_fix_generator_return
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_determine_best_return_type_single
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_determine_best_return_type_multiple
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_no_source_code_fallback
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnSuggestionGenerator::test_unknown_issue_type
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnGeneratorIntegration::test_complete_workflow_missing_returns
FAILED tests/suggestions/generators/test_return_generator.py::TestReturnGeneratorIntegration::test_complete_workflow_generator_function
======================== 76 failed, 43 passed in 3.89s ========================
